#include "qcom_common.h"
#include "hm_app.h"
#include "hm_zigbeeInfohand.h"
#include "qcom_uart.h"
#include "hm_otaDefine.h"
#include "hm_zigbeeStateDeal.h"
#include "qcom_pwm_api.h"

#include "ServerDataHandle.h"


uint8_t userOtaZigbeeGWCheck;
UART_RX_DATA_BUF uartRXData[MAX_UART_RX_BUF_NUM];
UART_TX_CMD_BUF  uartTXCmd[MAX_UART_TX_CMD_BUF_NUM];
uint8_t zigbeeNetWorkStation = ZB_NET_WORK_NORMAL;
uint8_t zigbeeNetPermitJoinTime;
extern uint8_t zcXmodemStation;
extern uint8_t devOtaUpdateingFlag;
extern DEV_OTA_STATION otaStationInfo;
extern DEV_MYSELF_INFO hmIotsDevInfo;
UARTCMDMONITOR uartCmdMonito[MAX_UART_CMD_MONITOR_NUM];//指令监测缓存，定期查询
UARTHEARTINFO uartHeartManage;//UART 心跳机制
extern DEV_NUM_INFO devNumInfo;
extern GWSTATFORTIME gwStateForRealTime;
extern WIFICMDWATIRSP wifiCmdWaitRspBuf[SPECIALCMDNUM];

static uint8_t zbJoinFlag = 0;
static uint8_t zbJoinDevNum = 0;

uint8_t zbSysStartFlag = 2;

//HM_DEV_RAM_LIST templist_pram;//缓存  hardy add new




static int userFillSpecialWatiRspCmdBuf(WIFICMDWATIRSP cmdsta)
{
	uint8_t i,tempIndex = 0xff;
	int ret = 0;
	for(i = 0; i < SPECIALCMDNUM; i ++)
	{
		if(wifiCmdWaitRspBuf[i].valid == 0)
		{
			if(tempIndex == 0xff)
			{
				tempIndex = i;
			}
		}else if(wifiCmdWaitRspBuf[i].valid == 1){//如果之前有缓存改指令
			if((wifiCmdWaitRspBuf[i].zbCmd == cmdsta.zbCmd) && (wifiCmdWaitRspBuf[i].zbClusterId == cmdsta.zbClusterId) && (wifiCmdWaitRspBuf[i].zbEp == cmdsta.zbEp)&& (wifiCmdWaitRspBuf[i].zbShortAddr == cmdsta.zbShortAddr))
			{
				wifiCmdWaitRspBuf[i].rcvTimems = gwStateForRealTime.sysRealTimeFors;
				return ret;
			}
		}else{
			wifiCmdWaitRspBuf[i].valid = 0;
			if(tempIndex == 0xff)
			{
				tempIndex = i;
			}
		}
	}
	if(tempIndex < SPECIALCMDNUM)
	{
		wifiCmdWaitRspBuf[tempIndex].cmdSn = cmdsta.cmdSn;
		wifiCmdWaitRspBuf[tempIndex].zbClusterId = cmdsta.zbClusterId;
		wifiCmdWaitRspBuf[tempIndex].zbCmd = cmdsta.zbCmd;
		wifiCmdWaitRspBuf[tempIndex].zbEp = cmdsta.zbEp;
		wifiCmdWaitRspBuf[tempIndex].rcvTimems = gwStateForRealTime.sysRealTimeFors;
		wifiCmdWaitRspBuf[tempIndex].zbShortAddr = cmdsta.zbShortAddr;
		wifiCmdWaitRspBuf[tempIndex].setData = cmdsta.setData;
		wifiCmdWaitRspBuf[tempIndex].valid = 1;
	}else{
		ret = -1;
	}
	return ret;
}

int userUartSendWithDebugFunc(unsigned char *data, int len)
{
	int ret;
#ifdef  HM_DEBUG
	char outTxHex[150];
	uint8_t i;
	memset(outTxHex,'\0',150);
	for(i = 0; i < len; i ++)
	{
		sprintf(outTxHex,"%s %02x",outTxHex,data[i]);
	}
	printf("uart tx:%s\r\n",outTxHex);
#endif
	ret = qca_uart_send(data,len);
	return ret;
}


uint8_t checkIEEEAddrHasActive(EmberEUI64 checkEui64)
{
    const uint8_t unset1Eui64[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
    const uint8_t unset2Eui64[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    if ((0 == memcmp(checkEui64,unset1Eui64,8)) || 
        (0 == memcmp(checkEui64,unset2Eui64,8)))
    {
        return 0;
    }else{
        return 1;
    }
}

void fillUartCmdMonitor(uint8_t cmd,uint16_t shortAddr,uint8_t ep,uint8_t *cpcmdData,uint8_t cpcmdLen)
{
	uint8_t i;
	uint8_t tempIndex = 0xff;
	if(cpcmdLen > MAX_BACKUP_DATA_LEN)
	{
		printf("input the back up func data was too long\r\n");
		return;
	}
	for(i = 0; i < MAX_UART_CMD_MONITOR_NUM; i ++)
	{
		if(tempIndex > MAX_UART_CMD_MONITOR_NUM)
		{
			if(uartCmdMonito[i].validFlag == 0)
			{
				tempIndex = i;
			}
		}
		if((uartCmdMonito[i].cmd == cmd) && (uartCmdMonito[i].ep == ep) && (uartCmdMonito[i].shortAddr == shortAddr))
		{
			tempIndex = i;
			break;
		}
	}
	if(tempIndex < MAX_UART_CMD_MONITOR_NUM)
	{
		uartCmdMonito[tempIndex].cmd = cmd;
		uartCmdMonito[tempIndex].ep = ep;
		uartCmdMonito[tempIndex].shortAddr = shortAddr;
		uartCmdMonito[tempIndex].sendTime100Ms = (qcom_time_us()) >> 8;//除以1024，约等于100，在此时间精确度要求不高，为了节省CPU开销
		uartCmdMonito[tempIndex].validFlag = 1;
		uartCmdMonito[tempIndex].cmdbk.bkLen = cpcmdLen;
		memcpy(uartCmdMonito[tempIndex].cmdbk.bkBuff,cpcmdData,cpcmdLen);
	}
}


uint8_t findUartCmdMonitor(uint8_t cmd,uint16_t shortAddr,uint8_t ep)
{
	uint8_t i;
	for(i = 0; i < MAX_UART_CMD_MONITOR_NUM; i ++)
	{
		if(uartCmdMonito[i].validFlag == 1)
		{
			if(uartCmdMonito[i].cmd == cmd) 
			{
				if(shortAddr == 0xffff)//不需要匹配shortaddr 和ep
				{
					break;
				}else if((uartCmdMonito[i].ep == ep) && (uartCmdMonito[i].shortAddr == shortAddr)){
					break;
				}
			}
		}
	}
	if(i < MAX_UART_CMD_MONITOR_NUM)
	{
		return i;
	}else{
		return 0xff;
	}
}

void deleteUartCmdMonitor(uint8_t index)
{
	if(index < MAX_UART_CMD_MONITOR_NUM)
	{
		memset((uint8_t *)&uartCmdMonito[index],0,sizeof(UARTCMDMONITOR));
	}
}

void clearUartCmdMonitor(void)
{
	uint8_t i;
	for(i = 0; i < MAX_UART_CMD_MONITOR_NUM; i ++)
	{
		deleteUartCmdMonitor(i);
	}
}

/***************************************************************
函数名： userFineFreeRxBufIndex
输入参数： 无
输出参数： 空闲的RX BUF index
函数说明： 查找空闲的RXBuf的index
***************************************************************/
static uint8_t userFindFreeRxBufIndex(void) 
{
    uint8_t i;
    for(i = 0; i < MAX_UART_RX_BUF_NUM; i ++)
    {
        if(uartRXData[i].validFlag == ZB_INVALID_DATA)
        {
            return i;
        }
    }
    return UART_FIND_BUF_INVALID_INDEX;

}

/***************************************************************
函数名： userFindFreeTxBufIndex
输入参数： 无
输出参数： 空闲的TX BUF index
函数说明： 查找空闲的TXBuf的index
***************************************************************/
static uint8_t userFindFreeTxBufIndex(void) 
{
    uint8_t i;
    for(i = 0; i < MAX_UART_TX_CMD_BUF_NUM; i ++)
    {
        if(uartTXCmd[i].cmdValid == ZB_INVALID_DATA)
        {
            return i;
        }
    }
    return UART_FIND_BUF_INVALID_INDEX;

}

static void userClearValidUartTxBufIndex(uint8_t index)
{
    uartTXCmd[index].cmdValid = ZB_INVALID_DATA;
    uartTXCmd[index].dstAddr = 0;
    uartTXCmd[index].dstEp = 0;
    uartTXCmd[index].inCmd = 0;
}


void userFillUartCmdForPermitJoin(uint8_t joinTime)
{
	uint8_t tempTime = joinTime;
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = 0;
		uartTXCmd[uartTxIndex].dstEp = 1;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_PERMIT_JOIN_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
		uartTXCmd[uartTxIndex].inPayload.inData[0] = tempTime;
		uartTXCmd[uartTxIndex].inPayload.inDataLen = 1;
	}else{
		printf("not find free tx buf\r\n");
	}
}

void userFillUartCmdForHeart(void)
{
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = 0;
		uartTXCmd[uartTxIndex].dstEp = 1;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_SEND_ZC_HEART_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
	}else{
		printf("not find free tx buf\r\n");
	}
}

void userFillUartCmdForReadDevInfo(uint16_t shortAddr)
{
	/*uint8_t uartTxIndex = userFindFreeTxBufIndex();
	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = shortAddr;
		uartTXCmd[uartTxIndex].dstEp = 0;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_DEV_INFO_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
	}else{
		printf("not find free tx buf\r\n");
	}*///在此屏蔽读取模块上设备列表的功能，2017.8.22
}

void userFillUartCmdForReadZCnfo(void)
{
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = 0;
		uartTXCmd[uartTxIndex].dstEp = 1;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_READ_ZC_INFO_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
	}else{
		printf("not find free tx buf\r\n");
	}
}

void userFillUartCmdForLeaveDev(uint16_t shortAddr)
{
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = shortAddr;
		uartTXCmd[uartTxIndex].dstEp = 0;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_LEAVE_DEV_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
	}else{
		printf("not find free tx buf\r\n");
	}
}

void userFillUartCmdForZCOta(uint8_t softVersion)
{
	uint8_t tempVersion = softVersion;
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = 0;
		uartTXCmd[uartTxIndex].dstEp = 1;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_UPDATE_ZC_SOFT_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
		uartTXCmd[uartTxIndex].inPayload.inData[0] = tempVersion;
		uartTXCmd[uartTxIndex].inPayload.inDataLen = 1;
	}else{
		printf("not find free tx buf\r\n");
	}
}

void userFillUartCmdForSetZCToFactory(void)
{
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = 0;
		uartTXCmd[uartTxIndex].dstEp = 1;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_SET_ZC_TO_FACTORY_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
	}else{
		printf("not find free tx buf\r\n");
	}
}

void userFillUartCmdForSetZCReportRssi(void)
{
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = 0;
		uartTXCmd[uartTxIndex].dstEp = 1;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_SET_RSSI_REPORT_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
	}else{
		printf("not find free tx buf\r\n");
	}
}

void userFillUartCmdForNodeDescripte(uint16_t shortAddr)
{
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = shortAddr;
		uartTXCmd[uartTxIndex].dstEp = 0;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_GET_NODE_DESCRIPTOR_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
	}else{
		printf("not find free tx buf\r\n");
	}
}

void userFillUartCmdForOnOff(uint16_t shortAddr, uint8_t ep,uint8_t state)
{
	uint8_t onOffState = state;
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = shortAddr;
		uartTXCmd[uartTxIndex].dstEp = ep;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_ONOFF_CONTROL_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
		uartTXCmd[uartTxIndex].inPayload.inDataLen = 1;
		uartTXCmd[uartTxIndex].inPayload.inData[0] = onOffState;
	}else{
		printf("not find free tx buf\r\n");
	}
}

int userSetNodeSensitivityLevel(uint16_t shortAddr,uint8_t ep,uint8_t state,uint32_t cmdSn)
{
	int ret = 0;
	WIFICMDWATIRSP tempData;
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = shortAddr;
		uartTXCmd[uartTxIndex].dstEp = ep;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_WRITE_ATTR_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
		uartTXCmd[uartTxIndex].inPayload.inDataLen = 7;
		uartTXCmd[uartTxIndex].inPayload.inData[0] = ZCL_IAS_ZONE_CLUSTER_ID & 0xff;
		uartTXCmd[uartTxIndex].inPayload.inData[1] = (ZCL_IAS_ZONE_CLUSTER_ID >> 8) & 0xff;
		uartTXCmd[uartTxIndex].inPayload.inData[2] = 0x02;//zcl com write attr
		uartTXCmd[uartTxIndex].inPayload.inData[3] = ZCL_CURRENT_ZONE_SENSITIVITY_LEVEL_ATTRIBUTE_ID & 0xff;
		uartTXCmd[uartTxIndex].inPayload.inData[4] = (ZCL_CURRENT_ZONE_SENSITIVITY_LEVEL_ATTRIBUTE_ID >> 8) & 0xff;
		uartTXCmd[uartTxIndex].inPayload.inData[5] = 0x20;//data type :uint8_t
		uartTXCmd[uartTxIndex].inPayload.inData[6] = state;


		tempData.cmdSn = cmdSn;
		tempData.setData = state;
		tempData.zbClusterId = ZCL_IAS_ZONE_CLUSTER_ID;
		tempData.zbCmd = UART_CMD_WRITE_ATTR_REQ;
		tempData.zbEp = ep;
		tempData.zbShortAddr = shortAddr;
		userFillSpecialWatiRspCmdBuf(tempData);
	}else{
		printf("not find free tx buf\r\n");
		ret = -1;
	}
	return ret;
}

void userFillUartCmdForBrightness(uint16_t shortAddr, uint8_t ep,uint8_t brightness)
{
	printf("fill brightness control\r\n");
	uint8_t level = brightness;
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = shortAddr;
		uartTXCmd[uartTxIndex].dstEp = ep;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_RGBLIGHT_CONTROL_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
		uartTXCmd[uartTxIndex].inPayload.inDataLen = 2;
		uartTXCmd[uartTxIndex].inPayload.inData[0] = 0;//brightness control
		uartTXCmd[uartTxIndex].inPayload.inData[1] = level;
	}else{
		printf("not find free tx buf\r\n");
	}
}

void userFillUartCmdForColorTemperature(uint16_t shortAddr, uint8_t ep,uint16_t colorTemp)
{
	printf("fill color temp control\r\n");
	uint16_t colorT = colorTemp;
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = shortAddr;
		uartTXCmd[uartTxIndex].dstEp = ep;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_RGBLIGHT_CONTROL_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
		uartTXCmd[uartTxIndex].inPayload.inDataLen = 3;
		uartTXCmd[uartTxIndex].inPayload.inData[0] = 1;//color temperature control
		uartTXCmd[uartTxIndex].inPayload.inData[1] = colorT & 0xff;
		uartTXCmd[uartTxIndex].inPayload.inData[2] = (colorT >> 8) & 0xff;
	}else{
		printf("not find free tx buf\r\n");
	}
}

void userFillUartCmdForOnOffByGroupsOrBroadcast(uint16_t addr, uint8_t addrType,uint8_t state)
{
	uint8_t onOffState = state;
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = addr;
		uartTXCmd[uartTxIndex].dstEp = addrType;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_ONOFF_CONTROL_BY_GROUP_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
		uartTXCmd[uartTxIndex].inPayload.inDataLen = 1;
		uartTXCmd[uartTxIndex].inPayload.inData[0] = onOffState;
	}else{
		printf("not find free tx buf\r\n");
	}
}

void userFillUartCmdForLevel(uint16_t shortAddr, uint8_t ep,uint8_t subcmd,uint8_t level,uint8_t upOrDown)
{
	uint16_t transitionTime = 2; // 0.2s
	uint8_t inPayload[5];
	uint8_t payloadLen;
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	switch(subcmd)
	{
		case MOVE_TO_LEVEL_WTONOFF:
			inPayload[1] = level;
			inPayload[2] = transitionTime & 0xff;
			inPayload[3] = (transitionTime >> 8) & 0xff;
			payloadLen = 4;
			break;
		case STEP_WTONOFF:
			inPayload[1] = upOrDown;
			inPayload[2] = level;
			inPayload[3] = transitionTime & 0xff;
			inPayload[4] = (transitionTime >> 8) & 0xff;
			payloadLen = 5;
			break;
			//暂时不支持以下指令
		case MOVE_TO_LEVEL:
		case MOVE:
		case STEP:
		case MOVE_WTONOFF:
		case STOP:
		default: return;
	}
	inPayload[0] = subcmd;
	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = shortAddr;
		uartTXCmd[uartTxIndex].dstEp = ep;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_LEVEL_CONTROL_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
		memcpy(uartTXCmd[uartTxIndex].inPayload.inData,inPayload,payloadLen);
		uartTXCmd[uartTxIndex].inPayload.inDataLen = payloadLen;
	}else{
		printf("not find free tx buf\r\n");
	}
}


void userFillUartCmdForColorControl(uint16_t shortAddr, uint8_t ep,uint16_t r,uint16_t g,uint16_t b)
{
	uint16_t transitionTime = 2; // 0.2s
	uint8_t inPayload[7];
	uint8_t payloadLen;
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	uint16_t color_x;
	uint16_t color_y;
	uint8_t tempLevel;
	hmzColorRgbToXY(r,g,b,&color_x,&color_y,&tempLevel);
	inPayload[0] = MOVE_TO_COLOR;
	inPayload[1] = color_x & 0xff;
	inPayload[2] = (color_x >> 8) & 0xff;
	inPayload[3] = color_y & 0xff;
	inPayload[4] = (color_y >> 8) & 0xff;
	inPayload[5] = transitionTime & 0xff;
	inPayload[6] = (transitionTime >> 8) & 0xff;
	payloadLen = 7;
	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = shortAddr;
		uartTXCmd[uartTxIndex].dstEp = ep;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_COLOR_CONTROL_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
		memcpy(uartTXCmd[uartTxIndex].inPayload.inData,inPayload,payloadLen);
		uartTXCmd[uartTxIndex].inPayload.inDataLen = payloadLen;
	}else{
		printf("not find free tx buf\r\n");
	}
}


void userFillUartCmdForWd(uint16_t shortAddr , uint8_t ep,uint8_t subcmd, uint8_t warmMode,uint16_t duration,uint8_t strobeCycle,uint8_t strobeLevel)
{
	uint8_t inPayload[6];
	uint8_t payloadLen;
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	if(subcmd == START_WARNING)
	{
		inPayload[0] = START_WARNING;
		inPayload[1] = warmMode;
		inPayload[2] = duration & 0xff;
		inPayload[3] = (duration >> 8) & 0xff;
		inPayload[4] = strobeCycle;
		inPayload[5] = strobeLevel;
		payloadLen = 6;
	}else{
		return;
	}
	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = shortAddr;
		uartTXCmd[uartTxIndex].dstEp = ep;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_WD_CONTROL_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
		memcpy(uartTXCmd[uartTxIndex].inPayload.inData,inPayload,payloadLen);
		uartTXCmd[uartTxIndex].inPayload.inDataLen = payloadLen;
	}else{
		printf("not find free tx buf\r\n");
	}
}

void userAppControlWDFunc(uint16_t shortAddr , uint8_t ep,uint8_t action,uint16_t duration)
{
	if(action)
	{
		userFillUartCmdForWd(shortAddr,ep,START_WARNING,0x14,duration,40,0);
	}else{
		userFillUartCmdForWd(shortAddr,ep,START_WARNING,0,0,0,0);
	}
}

//目前只支持一个attr的读写，暂时不考虑多个，如果有需要，后续扩展
void userFillUartCmdForWriteAttr(uint16_t shortAddr , uint8_t ep,uint16_t clusterId, uint16_t attrId,uint8_t dataType,uint8_t dataLen,uint8_t *data)
{
	uint8_t inPayload[20];
	uint8_t payloadLen;
	uint8_t i;
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	if((data == NULL) || (dataLen > 8))
	{
		printf("fill write attr func:in put data point was invalid\r\n");
		return;
	}
	inPayload[0] = clusterId & 0xff;
	inPayload[1] = (clusterId >> 8) & 0xff;
	inPayload[2] = 2;//固定值( 保留)
	inPayload[3] = attrId & 0xff;
	inPayload[4] = (attrId >> 8 ) & 0xff;
	inPayload[5] = dataType;
	for(i = 0; i < dataLen; i ++)//字节序问题
	{
		inPayload[6 + i] = data[dataLen - 1 - i];
	}
	payloadLen = 6 + dataLen;
	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = shortAddr;
		uartTXCmd[uartTxIndex].dstEp = ep;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_WRITE_ATTR_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
		
		memcpy(uartTXCmd[uartTxIndex].inPayload.inData,inPayload,payloadLen);
		uartTXCmd[uartTxIndex].inPayload.inDataLen = payloadLen;
	}else{
		printf("not find free tx buf\r\n");
	}
}


void userFillUartCmdForReadAttr(uint16_t shortAddr , uint8_t ep,uint16_t clusterId, uint16_t attrId)
{
	uint8_t inPayload[5];
	uint8_t payloadLen;
	uint8_t i;
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	inPayload[0] = clusterId & 0xff;
	inPayload[1] = (clusterId >> 8) & 0xff;
	inPayload[2] = 0;//固定值( 保留)
	inPayload[3] = attrId & 0xff;
	inPayload[4] = (attrId >> 8 ) & 0xff;

	payloadLen = 5;
	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = shortAddr;
		uartTXCmd[uartTxIndex].dstEp = ep;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_READ_ATTR_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
		memcpy(uartTXCmd[uartTxIndex].inPayload.inData,inPayload,payloadLen);
		uartTXCmd[uartTxIndex].inPayload.inDataLen = payloadLen;
		
	}else{
		printf("not find free tx buf\r\n");
	}
}

void userFillUartCmdForConfigReporting(uint16_t shortAddr , uint8_t ep,uint16_t clusterId, uint16_t attrId,
											uint8_t dataType,uint16_t minTime,uint16_t maxTime,uint8_t dataLen,
											uint8_t *data)
{
	uint8_t inPayload[20];
	uint8_t payloadLen;
	uint8_t i;
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	inPayload[0] = clusterId & 0xff;
	inPayload[1] = (clusterId >> 8) & 0xff;
	inPayload[2] = 6;//固定值( 保留)
	inPayload[3] = 0;//固定direction
	inPayload[4] = attrId & 0xff;
	inPayload[5] = (attrId >> 8 ) & 0xff;
	inPayload[6] = dataType;
	inPayload[7] = minTime & 0xff;
	inPayload[8] = (minTime >> 8) & 0xff;
	inPayload[9] = maxTime & 0xff;
	inPayload[10] = (dataType >> 8) & 0xff;
	if(dataLen > 8)
	{
		return;
	}
	for(i = 0; i < dataLen; i ++)
	{
		inPayload[11 + i] = 0;
	}
	inPayload[11] = 1;
	payloadLen = 11 + dataLen;

	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = shortAddr;
		uartTXCmd[uartTxIndex].dstEp = ep;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_CFG_ATTR_REPORT_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
		memcpy(uartTXCmd[uartTxIndex].inPayload.inData,inPayload,payloadLen);
		uartTXCmd[uartTxIndex].inPayload.inDataLen = payloadLen;
	}else{
		printf("not find free tx buf\r\n");
	}
}

void userFillUartCmdForClusterBind(uint16_t shortAddr , uint8_t ep,uint8_t *dstmac ,uint8_t dstep,uint16_t clusterId)
{
	uint8_t inPayload[20];
	uint8_t payloadLen;
	uint8_t uartTxIndex = userFindFreeTxBufIndex();
	if(dstmac == NULL)
	{
		printf("fill the bind func:dst mac was null\r\n");
		return;
	}
	inPayload[0] = clusterId & 0xff;
	inPayload[1] = (clusterId >> 8) & 0xff;
	inPayload[2] = 3;//固定值(addr mode)
	memcpy(&inPayload[3],dstmac,8);
	inPayload[11] = dstep;

	payloadLen = 12;

	if(uartTxIndex != UART_FIND_BUF_INVALID_INDEX)
	{
		uartTXCmd[uartTxIndex].dstAddr = shortAddr;
		uartTXCmd[uartTxIndex].dstEp = ep;
		uartTXCmd[uartTxIndex].inCmd = UART_CMD_BIND_REQ;
		uartTXCmd[uartTxIndex].cmdValid = 1;
		memcpy(uartTXCmd[uartTxIndex].inPayload.inData,inPayload,payloadLen);
		uartTXCmd[uartTxIndex].inPayload.inDataLen = payloadLen;
	}else{
		printf("not find free tx buf\r\n");
	}
}


void userSetUartHeartTime(void)
{
	uint32_t temp_times;
	temp_times=time_ms() / 100;
	uartHeartManage.lastCommuTime100ms = temp_times;//time_ms() / 100;//(uint32_t)(qcom_time_us() / 100000);
	uartHeartManage.uartHeartSendCount = 0;
	printf("test 1111111111 the time:%d,ms time:%d\r\n",uartHeartManage.lastCommuTime100ms,temp_times);
}

void userManageUartHeart(void)
{
	uint32_t tempTimeMs = time_ms() / 100;//(uint32_t)(qcom_time_us() / 100000);
	
	if(tempTimeMs > uartHeartManage.lastCommuTime100ms)
	{
		if(uartHeartManage.uartHeartSendCount == 0)
		{
			if((tempTimeMs - uartHeartManage.lastCommuTime100ms) >= 600)// 1 min
			{
				userFillUartCmdForHeart();
				printf("fill send uart heart buf\r\n");
				uartHeartManage.lastCommuTime100ms = tempTimeMs;
				uartHeartManage.uartHeartSendCount ++;
			}
		}else{
			if((tempTimeMs - uartHeartManage.lastCommuTime100ms) >= 50)// 5 s
			{
				if(uartHeartManage.uartHeartSendCount >= 2)
				{
					uartHeartManage.lastCommuTime100ms = tempTimeMs;
					uartHeartManage.uartHeartSendCount = 0;
					uartHeartManage.uartWorkDataType = UART_WORK_COMMUNICATION;
					printf("the zc not respose the heart,reset it now\r\n");
					zigbeeModeReset();
				}else{
					userFillUartCmdForHeart();
					printf("refill send uart heart buf\r\n");
					uartHeartManage.lastCommuTime100ms = tempTimeMs;
					uartHeartManage.uartHeartSendCount ++;
				}
			}
		}
	}else{
		uartHeartManage.lastCommuTime100ms = tempTimeMs;
	}
}



/***************************************************************
函数名： calcFCS
输入参数： 
pMsg:校验数据指针
len：校验数据长度
输出参数： 校验值
函数说明： 异或和校验
***************************************************************/
static unsigned char calcFCS(unsigned char *pMsg, unsigned char len) 
{ 
    unsigned char result = 0; 
    while (len--) 
    { 
      result ^= *pMsg++; 
    } 
    return result; 
} 


void userSetOtaZigbeeGWFlag(void)
{
    devOtaUpdateingFlag = 1;
}

void userClearOtaZigbeeGWFlag(void)
{
    devOtaUpdateingFlag = 0;
}

uint8_t userCheckOtaZigbeeGWFlag(void)
{
    return devOtaUpdateingFlag;
}

/***************************************************************
函数名： userFromInFineValidUartTxBufIndex
输入参数： 
in:起始index
输出参数： 有效的（有需要处理的）index
函数说明： 从in开始查找剩下需要处理的TXbuf的index
***************************************************************/
static uint8_t userFromInFineValidUartTxBufIndex(uint8_t in)
{
    uint8_t i;
    for(i = in; i < MAX_UART_TX_CMD_BUF_NUM; i ++)
    {
        if(uartTXCmd[i].cmdValid == 1)
        {
            return i;
        }
    }
    return UART_FIND_BUF_INVALID_INDEX;
}



void uartRcvDataDeal(uint8_t* data,uint16_t dataLen)
{
    uint8_t index,tempOnline;
    uint16_t shortAddr,clusterId,attrId,alarmStatus;
    uint16_t alarmCluster;
    uint8_t alarmCode;
    uint8_t aceCom,armMode;
    uint8_t ep;
    uint8_t addrType;
    uint8_t subType,cpbrightness;
    uint8_t tempMac[8];
    uint16_t cpHumi,cpcolorTemp;
    int16_t cpTmep;
    uint16_t colorValue;
    uint64_t cpPowerKwh;
    uint32_t cpPowerKw;
    uint16_t cpVoltage;
    UART_UPDATE_NEW_DEV_DATA_INFO newDevData;
    HM_DEV_RAM_LIST *pRam;////HM_DEV_RAM_LIST *pRam=&templist_pram;//temp_pram
    HM_DEV_FLASH_INFO tempFlashData;
    uint16_t devIndex;
    uint8_t i;
    if(data == NULL)
    {
        printf("the uart data was null\r\n");
        return;
    }
    if(data[0] == 0xfa)
    {
        if(data[1] != (dataLen - 4))//协议数据长度不包含包头、自身、校验、包尾
        {
            printf("the uart data was invalid\r\n");
            return;
        }
        if(calcFCS(&data[3],dataLen - 5) == data[dataLen - 2])//校验正确
        {
            userSetUartHeartTime();
	     printf("uart data check was success,cmd:%02x\r\n",data[2]);
            uint8_t cmd = data[2];
            switch(cmd)
            {
                case UART_CMD_PERMIT_JOIN_RSP:
                	printf("test for uart rcv permit join\r\n");
                	if(data[3] == 0)
                	{
                		if(data[4] != 0)
                		{
					zigbeeNetWorkStation = ZB_NET_WORK_PERMIT_JOINING;//影响灯的指示状态的标志位
					zigbeeNetPermitJoinTime = data[4];
					gwStateForRealTime.gwZbIsJoining = 1;
					zbJoinFlag = 1;//为了检测是否有设备网，判断是否需要update echo list
				}else{
					zigbeeNetWorkStation = ZB_NET_WORK_NORMAL;
					gwStateForRealTime.gwZbIsJoining = 0;
				}
                	}else{
				printf("uart rsp:set zc to permit join was faild\r\n");
                	}
                	index = findUartCmdMonitor(cmd - 1,MONITOR_FIND_FOR_ZC_SHORTADDR,1);
                	if(index < MAX_UART_CMD_MONITOR_NUM)
                	{
				deleteUartCmdMonitor(index);
                	}
                	break;
                case UART_CMD_LEAVE_DEV_RSP://在此只能表示ZC接收到了离网请求指令，真正设备的离网需要看idct指令
			index = findUartCmdMonitor(cmd - 1,MONITOR_FINE_FOR_ANY_SHORTADDR,0);
                	if(index < MAX_UART_CMD_MONITOR_NUM)
                	{
				deleteUartCmdMonitor(index);
                	}
                	break;
                case UART_CMD_ONOFF_CONTROL_RSP:
                      if(data[3] == 0)
                	{
				printf("onoff control success\r\n");
                	}else{
				printf("onoff control faild\r\n");
                	}
                     shortAddr = data[4] + ((uint16_t)data[5] << 8);
                	ep = data[6];
               	index = findUartCmdMonitor(cmd - 1,shortAddr,ep);
               	if(index < MAX_UART_CMD_MONITOR_NUM)
               	{
	               	uartCmdMonito[index].rspRcvFlag = 1;
	               	uartCmdMonito[index].cmd = MONITOR_SUB_CMD_ONOFF;
               	}
                	break;
                case UART_CMD_RGBLIGHT_CONTROL_RSP:
                      if(data[3] == 0)
                	{
				printf("cutrgb control success\r\n");
                	}else{
				printf("cutrgb control faild\r\n");
                	}
                     shortAddr = data[4] + ((uint16_t)data[5] << 8);
                	ep = data[6];
               	index = findUartCmdMonitor(cmd - 1,shortAddr,ep);
               	if(index < MAX_UART_CMD_MONITOR_NUM)
               	{
	               	uartCmdMonito[index].rspRcvFlag = 1;
	               	uartCmdMonito[index].cmd = MONITOR_SUB_CMD_CUTRGB;
               	}
                	break;
                case UART_CMD_COLOR_CONTROL_RSP:
                      if(data[3] == 0)
                	{
				printf("color control success\r\n");
                	}else{
				printf("color control faild\r\n");
                	}
                     shortAddr = data[4] + ((uint16_t)data[5] << 8);
                	ep = data[6];
               	index = findUartCmdMonitor(cmd - 1,shortAddr,ep);
               	if(index < MAX_UART_CMD_MONITOR_NUM)
               	{
	               	uartCmdMonito[index].rspRcvFlag = 1;
	               	uartCmdMonito[index].cmd = MONITOR_SUB_CMD_COLOR;
               	}
                	break;                	
                case UART_CMD_LEVEL_CONTROL_RSP:
                      if(data[3] == 0)
                	{
				printf("level control success\r\n");
                	}else{
				printf("level control faild\r\n");
                	}
                	shortAddr = data[4] + ((uint16_t)data[5] << 8);
                	ep = data[6];
               	index = findUartCmdMonitor(cmd - 1,shortAddr,ep);
               	if(index < MAX_UART_CMD_MONITOR_NUM)
               	{
	               	uartCmdMonito[index].rspRcvFlag = 1;
	               	uartCmdMonito[index].cmd = MONITOR_SUB_CMD_LEVEL;
               	}
                	break;
                case UART_CMD_SET_ZC_TO_FACTORY_RSP:
                	if(data[3] == 0)//指令执行成功才清楚监听缓存
                	{
				index = findUartCmdMonitor(cmd - 1,MONITOR_FIND_FOR_ZC_SHORTADDR,1);
	                	if(index < MAX_UART_CMD_MONITOR_NUM)
	                	{
					deleteUartCmdMonitor(index);
	                	}
                	}
                	break;
                case UART_CMD_WD_CONTROL_RSP:
                      if(data[3] == 0)
                	{
				printf("wd control success\r\n");
                	}else{
				printf("wd control faild\r\n");
                	}
                     shortAddr = data[4] + ((uint16_t)data[5] << 8);
                	ep = data[6];
               	index = findUartCmdMonitor(cmd - 1,shortAddr,ep);
               	if(index < MAX_UART_CMD_MONITOR_NUM)
               	{
	               	deleteUartCmdMonitor(index);
               	}
               	//(for working lixiong)//write recode to cloud 
                	break;
                case UART_CMD_IDENTIFY_RSP:
                	if(data[3] == 0)
                	{
				printf("indentify control success\r\n");
                	}else{
				printf("indentify control faild\r\n");
                	}
                     shortAddr = data[4] + ((uint16_t)data[5] << 8);
                	ep = data[6];
               	index = findUartCmdMonitor(cmd - 1,shortAddr,ep);
               	if(index < MAX_UART_CMD_MONITOR_NUM)
               	{
	               	deleteUartCmdMonitor(index);
               	}
                	break;
                case UART_CMD_ONOFF_CONTROL_BY_GROUP_RSP:
                	 if(data[3] == 0)
                	{
				printf("on off  control by groups success\r\n");
                	}else{
				printf("on off  control by groups faild\r\n");
                	}
                      shortAddr = data[4] + ((uint16_t)data[5] << 8);
                	addrType = data[6];
               	index = findUartCmdMonitor(cmd - 1,shortAddr,addrType);
               	if(index < MAX_UART_CMD_MONITOR_NUM)
               	{
	               	deleteUartCmdMonitor(index);
               	}
                	break;
                case UART_CMD_READ_ZC_INFO_RSP:
                	if(data[1] == 14)
                	{
	                	gwStateForRealTime.zigbeeZcBasicInfo.channel = data[3];
	                	gwStateForRealTime.zigbeeZcBasicInfo.zcSoftVersion = data[4];
	                	gwStateForRealTime.zigbeeZcBasicInfo.panId = data[6] + (uint16_t)(data[7] << 8);
	                	memcpy(gwStateForRealTime.zigbeeZcBasicInfo.zbMac,&data[9],8);
	                	printf("zc channel:%d,soft version:%02x,pan id:%d\r\n",gwStateForRealTime.zigbeeZcBasicInfo.channel,gwStateForRealTime.zigbeeZcBasicInfo.zcSoftVersion,gwStateForRealTime.zigbeeZcBasicInfo.panId);
                	}else{
				printf("zc info rsp len was invalid\r\n");
                	}
                	break;
                case UART_CMD_SEND_ZC_HEART_RSP:
                    	break;
                case UART_CMD_UPDATE_ZC_SOFT_RSP:
                	printf("update rsp:the zc soft version was not newest them itself:%d\r\n",data[3]);
                	break;
                case UART_CMD_WRITE_ATTR_RSP:
                      if(data[9] == 0)
                	{
				printf("write attr was  success\r\n");
                	}else{
				printf("write attr was faild\r\n");
                	}
                      shortAddr = data[3] + ((uint16_t)data[4] << 8);
                	ep = data[5];
                	clusterId = data[6] + ((uint16_t)data[7] << 8);
                	if(clusterId == ZCL_IAS_ZONE_CLUSTER_ID)
                	{
				userDealWriteAttrCmdRspEvent(shortAddr,clusterId,ep,1);
                	}
               	index = findUartCmdMonitor(cmd - 1,shortAddr,ep);
               	if(index < MAX_UART_CMD_MONITOR_NUM)
               	{
	               	deleteUartCmdMonitor(index);
               	}
                	break;
                case UART_CMD_NEW_DEV_IDCT:
                	if((dataLen -5) <= sizeof(UART_UPDATE_NEW_DEV_DATA_INFO))
                	{
                		zbJoinDevNum ++;//为了检测是否有设备网，判断是否需要update echo list
                		memcpy(newDevData.macAddr ,&data[3],8);
                		newDevData.netState = data[11];
                		newDevData.batteryRemain = data[12];
                		newDevData.deviceId = data[13] + ((uint16_t)data[14] << 8);
                		newDevData.shortAddr = data[15] +( (uint16_t)data[16] << 8);
                		newDevData.epId = data[17];
                		memcpy(newDevData.modeId,&data[18],ZIGBEE_MODEID_LEN);
                		printf("the new dev mode id:%s",newDevData.modeId);
                		printf("new node id:%04x,devId:%04x,mac:%02x",newDevData.shortAddr,newDevData.deviceId,newDevData.macAddr[0]);
						printf(" %02x %02x %02x %02x %02x %02x %02x\n",newDevData.macAddr[1],newDevData.macAddr[2],newDevData.macAddr[3],newDevData.macAddr[4],newDevData.macAddr[5],\
							newDevData.macAddr[6],newDevData.macAddr[7]);
						if(checkIEEEAddrHasActive(newDevData.macAddr))
                		{
                			if(dataLen > 36)//不包含校验和包尾
                			{
						userNewDevJoiningDetectedEvent((char*)&newDevData,&data[34],dataLen - 36);
					}else{
						userNewDevJoiningDetectedEvent((char*)&newDevData,NULL,0);
					}
				}else{
					printf("the new dev mac was not valid\r\n");
				}
                	}else{
				printf("the new dev data len was error:%d\r\n",dataLen - 5);
                	}
                	break;
                case UART_CMD_IAS_ZONE_ALARM_IDCT:
                	shortAddr = data[3] + ((uint16_t)data[4] << 8);
                	ep = data[5];
               	alarmStatus = data[9] + ((uint16_t)data[10] << 8);
               	pRam = findInDevListByNwkadd(shortAddr);
               	if(pRam == NULL)
               	{
				//read zc the node mac
				printf("the short addr not find in dev table,read from zc now\r\n");
				userFillUartCmdForReadDevInfo(shortAddr);
               	}else{
               		setIasAlarmDetectedEvent(pRam,alarmStatus);
               	}
               	break;
                case UART_CMD_DEV_ALARM_IDCT:
                	shortAddr = data[3] + ((uint16_t)data[4] << 8);
                	ep = data[5];
                	alarmCode = data[9];
                	alarmCluster = data[10] + ((uint16_t)data[11] << 8);
                	pRam = findInDevListByNwkadd(shortAddr);
               	if(pRam == NULL)
               	{
				//read zc the node mac
				printf("the short addr not find in dev table,read from zc now\r\n");
				userFillUartCmdForReadDevInfo(shortAddr);
               	}else{
               		setAlarmsAlarmDetectedEvent(pRam,alarmCluster,alarmCode);
               	}
               	break;
                case UART_CMD_IAS_ACE_COM_IDCT:
                      shortAddr = data[3] + ((uint16_t)data[4] << 8);
                	ep = data[5];
                	aceCom = data[8];
                	pRam = findInDevListByNwkadd(shortAddr);
                	if(pRam == NULL)
               	{
				//read zc the node mac
				printf("the short addr not find in dev table,read from zc now\r\n");
				userFillUartCmdForReadDevInfo(shortAddr);
               	}else{
               		pRam->epList[0].times = gwStateForRealTime.sysRealTimeFors;
				setAceComDetectedEvent(pRam,aceCom,&data[9],data[1] - 7);
               	}
                	break;
                case UART_CMD_READ_ATTR_RSP:
                	shortAddr = data[3] + ((uint16_t)data[4] << 8);
                	ep = data[5];
                	clusterId = data[6] + ((uint16_t)data[7] << 8);
                	attrId = data[9] + ((uint16_t)data[10] << 8);
                	if(data[10] == 0)
                	{
				printf("read attr success\r\n");
                	}else{
				printf("read attr faild\r\n");
				break;
                	}
                	pRam = findInDevListByNwkadd(shortAddr);
                	if(pRam == NULL)
               	{
				//read zc the node mac
				printf("read attr:the short addr not find in dev table,read from zc now\r\n");
				userFillUartCmdForReadDevInfo(shortAddr);
               	}else{
	                	if(clusterId == ZCL_ON_OFF_CLUSTER_ID)
	                	{
		               	if(attrId == ZCL_ON_OFF_ATTRIBUTE_ID)
		               	{
		               		setNodeOnoffDetectedEvent(pRam,ep,data[13]);
		               	}else{
						printf("for on off cluster:not valid attr id for read attr\r\n");
		               	}
	                	}else if(clusterId == ZCL_LEVEL_CONTROL_CLUSTER_ID){
		               	if(attrId == ZCL_CURRENT_LEVEL_ATTRIBUTE_ID)
		               	{
		               		setNodeLevelDetectedEvent(pRam,ep,data[13]);
		               	}else{
						printf("for level cluster:not valid attr id for read attr\r\n");
		               	}
	                	}else if(clusterId == ZCL_COLOR_CONTROL_CLUSTER_ID){
		               	colorValue = (uint16_t)(data[13] + ((uint16_t)data[14] << 8));
		               	if(attrId == ZCL_COLOR_CONTROL_CURRENT_X_ATTRIBUTE_ID)
		               	{
						setNodeColorDetectedEvent(pRam,ep,'x',colorValue);
		               	}else if(attrId == ZCL_COLOR_CONTROL_CURRENT_Y_ATTRIBUTE_ID){
						setNodeColorDetectedEvent(pRam,ep,'y',colorValue);
		               	}else{
						printf("for color cluster:not valid attr id for read attr\r\n");
		               	}
	                	}else if(clusterId == ZCL_POWER_CONFIG_CLUSTER_ID){
	                		if(attrId == ZCL_BATTERY_PERCENTAGE_REMAINING_ATTRIBUTE_ID)
	                		{
						setNodeBatteryDetectedEvent(pRam, data[13]);
					}else{
						printf("for power cluster:not valid attr id for read attr\r\n");
					}
	                	}else if(clusterId == ZCL_TEMP_MEASUREMENT_CLUSTER_ID){
	                		if(attrId == ZCL_TEMP_MEASURED_VALUE_ATTRIBUTE_ID)
	                		{
		                		cpTmep = (int16_t)(data[13] + ((uint16_t)data[14] << 8));
						setNodeTemperatureDetectedEvent(pRam, ep, cpTmep);
					}else{
						printf("for temp cluster:not valid attr id for read attr\r\n");
					}
	                	}else if(clusterId == ZCL_RELATIVE_HUMIDITY_MEASUREMENT_CLUSTER_ID){
	                		if(attrId == ZCL_RELATIVE_HUMIDITY_MEASURED_VALUE_ATTRIBUTE_ID)
	                		{
						cpHumi = data[13] + ((uint16_t)data[14] << 8);
						setNodeHumilityDetectedEvent(pRam, ep, cpHumi);
					}else{
						printf("for humi cluster:not valid attr id for read attr\r\n");
					}
	                	}else if(clusterId == ZCL_SIMPLE_METERING_CLUSTER_ID){
					 if(attrId == ZCL_CURRENT_SUMMATION_DELIVERED_ATTRIBUTE_ID)//48bit
					 {
					 	cpPowerKwh = data[13] + ((uint64_t)data[14] << 8) + ((uint64_t)data[15] << 16) + ((uint64_t)data[16] << 24) 
					 				+ ((uint64_t)data[17] << 32) + ((uint64_t)data[18] << 40);
						setNodePowerKWHDetectedEvent(pRam,ep,cpPowerKwh);
					 }else if(attrId == ZCL_INSTANTANEOUS_DEMAND_ATTRIBUTE_ID)//24bit
					 {
					 	cpPowerKw = data[13] + ((uint32_t)data[14] << 8) + ((uint32_t)data[15] << 16) ;		
						setNodePowerKWDetectedEvent(pRam,ep,cpPowerKw);
					 }else{
						printf("for simple meter cluster:not valid attr id for read attr\r\n");
					 }
	                	}else if(clusterId == ZCL_ELECTRICAL_MEASUREMENT_CLUSTER_ID){
					 if(attrId == ZCL_RMS_VOLTAGE_ATTRIBUTE_ID)
					 {
					 	cpVoltage =  data[13] + ((uint32_t)data[14] << 8);
					 	//暂时关闭计量插座电压检测功能
						//setNodeVoltageDetectedEvent(pRam,ep,cpVoltage);
					 }else{
						printf("for electrical cluster:not valid attr id for read attr\r\n");
					 }
	                	}else if(clusterId == ZCL_IAS_ZONE_CLUSTER_ID){
					 if(attrId == ZCL_CURRENT_ZONE_SENSITIVITY_LEVEL_ATTRIBUTE_ID)
					 {
						setNodeSensitivityLevelEvent(pRam,data[13]);
					 }else{
						printf("for simple meter cluster:not valid attr id for read attr\r\n");
					 }
	                	}
	              }
                     break;
                case UART_CMD_ATTR_REPORT_IDCT:
					shortAddr = data[3] + ((uint16_t)data[4] << 8);
                	ep = data[5];
                	clusterId = data[6] + ((uint16_t)data[7] << 8);
                	attrId = data[9] + ((uint16_t)data[10] << 8);
                	pRam = findInDevListByNwkadd(shortAddr);
                	if(pRam == NULL)
               	{
				//read zc the node mac
				printf("the short addr not find in dev table,read from zc now\r\n");
				userFillUartCmdForReadDevInfo(shortAddr);
               	}else{
	                	if(clusterId == ZCL_ON_OFF_CLUSTER_ID)
	                	{
					index = findUartCmdMonitor(MONITOR_SUB_CMD_ONOFF,shortAddr,ep);
		               	if(index < MAX_UART_CMD_MONITOR_NUM)
		               	{
			               	deleteUartCmdMonitor(index);
		               	}
		               	if(attrId == ZCL_ON_OFF_ATTRIBUTE_ID)
		               	{
		               		setNodeOnoffDetectedEvent(pRam,ep,data[12]);
		               	}else{
						printf("for on off cluster:not valid attr id for report\r\n");
		               	}
	                	}else if(clusterId == ZCL_LEVEL_CONTROL_CLUSTER_ID){
					index = findUartCmdMonitor(MONITOR_SUB_CMD_LEVEL,shortAddr,ep);
		               	if(index < MAX_UART_CMD_MONITOR_NUM)
		               	{
			               	deleteUartCmdMonitor(index);
		               	}
		               	if(attrId == ZCL_CURRENT_LEVEL_ATTRIBUTE_ID)
		               	{
		               		setNodeLevelDetectedEvent(pRam,ep,data[12]);
		               	}else{
						printf("for level cluster:not valid attr id for report\r\n");
		               	}
	                	}else if(clusterId == ZCL_COLOR_CONTROL_CLUSTER_ID){
					index = findUartCmdMonitor(MONITOR_SUB_CMD_COLOR,shortAddr,ep);
		               	if(index < MAX_UART_CMD_MONITOR_NUM)
		               	{
			               	deleteUartCmdMonitor(index);
		               	}
		               	colorValue = (uint16_t)(data[12] + ((uint16_t)data[13] << 8));
		               	printf("the color value:%d\r\n",colorValue);
		               	if(attrId == ZCL_COLOR_CONTROL_CURRENT_X_ATTRIBUTE_ID)
		               	{
						setNodeColorDetectedEvent(pRam,ep,'x',colorValue);
		               	}else if(attrId == ZCL_COLOR_CONTROL_CURRENT_Y_ATTRIBUTE_ID){
						setNodeColorDetectedEvent(pRam,ep,'y',colorValue);
		               	}else{
						printf("for color cluster:not valid attr id for report\r\n");
		               	}
	                	}else if(clusterId == ZCL_POWER_CONFIG_CLUSTER_ID){
	                		if(attrId == ZCL_BATTERY_PERCENTAGE_REMAINING_ATTRIBUTE_ID)
	                		{
						setNodeBatteryDetectedEvent(pRam, data[12]);
					}else{
						printf("for power cluster:not valid attr id for report\r\n");
					}
	                	}else if(clusterId == ZCL_TEMP_MEASUREMENT_CLUSTER_ID){
	                		if(attrId == ZCL_TEMP_MEASURED_VALUE_ATTRIBUTE_ID)
	                		{
		                		cpTmep = (int16_t)(data[12] + ((uint16_t)data[13] << 8));
						setNodeTemperatureDetectedEvent(pRam, ep, cpTmep);
					}else{
						printf("for temp cluster:not valid attr id for report\r\n");
					}
	                	}else if(clusterId == ZCL_RELATIVE_HUMIDITY_MEASUREMENT_CLUSTER_ID){
	                		if(attrId == ZCL_RELATIVE_HUMIDITY_MEASURED_VALUE_ATTRIBUTE_ID)
	                		{
						cpHumi = data[12] + ((uint16_t)data[13] << 8);
						setNodeHumilityDetectedEvent(pRam, ep, cpHumi);
					}else{
						printf("for humi cluster:not valid attr id for report\r\n");
					}
	                	}else if(clusterId == ZCL_SIMPLE_METERING_CLUSTER_ID){
					 if(attrId == ZCL_CURRENT_SUMMATION_DELIVERED_ATTRIBUTE_ID)//48bit
					 {
					 	cpPowerKwh = data[12] + ((uint64_t)data[13] << 8) + ((uint64_t)data[14] << 16) + ((uint64_t)data[15] << 24) 
					 				+ ((uint64_t)data[16] << 32) + ((uint64_t)data[17] << 40);
						setNodePowerKWHDetectedEvent(pRam,ep,cpPowerKwh);
					 }else if(attrId == ZCL_INSTANTANEOUS_DEMAND_ATTRIBUTE_ID)//24bit
					 {
					 	cpPowerKw = data[12] + ((uint32_t)data[13] << 8) + ((uint32_t)data[14] << 16) ;		
						setNodePowerKWDetectedEvent(pRam,ep,cpPowerKw);
					 }else{
						printf("for simple meter cluster:not valid attr id for report\r\n");
					 }
	                	}else if(clusterId == ZCL_ELECTRICAL_MEASUREMENT_CLUSTER_ID){
					 if(attrId == ZCL_RMS_VOLTAGE_ATTRIBUTE_ID)
					 {
					 	cpVoltage =  data[12] + ((uint32_t)data[13] << 8);
					 	//暂时关闭计量插座电压检测功能
						//setNodeVoltageDetectedEvent(pRam,ep,cpVoltage);
					 }else{
						printf("for electrical cluster:not valid attr id for report\r\n");
					 }
	                	}else if(clusterId == ZCL_RGBLIGHT_CLUSTER_ID){
					index = findUartCmdMonitor(MONITOR_SUB_CMD_CUTRGB,shortAddr,ep);
		               	if(index < MAX_UART_CMD_MONITOR_NUM)
		               	{
			               	deleteUartCmdMonitor(index);
		               	}
	                	
 					if(attrId == ZCL_BRIGHTNESS_ATTRIBUTE_ID)
					 {
					 	cpbrightness =  data[12];
						setNodeBrightnessDetectedEvent(pRam,ep,cpbrightness);
					 }else if(attrId == ZCL_COLOR_TEMPERATURE_ATTRIBUTE_ID)
					 {
					 	cpcolorTemp =  data[12] + ((uint32_t)data[13] << 8);
						setNodeColorTempDetectedEvent(pRam,ep,cpcolorTemp);
					 }else{
						printf("for electrical cluster:not valid attr id for report\r\n");
					 }
	                	}
	              }
                     break;
                case UART_CMD_DEV_LEAVE_IDCT:
                	printf("leave the node\r\n");
                	memcpy(tempMac,&data[3],8);
                	if(checkIEEEAddrHasActive(tempMac))
                	{
				pRam = findInDevListByMac(tempMac);
				if(pRam == NULL)
				{
					printf("the leave node is not in dev list\r\n");
				}else{
					//hardy add 
					sent_zigbeelist_msg(pRam,DEL_ZIGBEE_MODE,1,1);
					printf("remove the node form the list now,index:%d\r\n",pRam->index);
					userDeleteDevFromLightNightAndHomeArm(pRam->index);
					userDeleteDevFromWDLinkList(pRam->index);
					userDeleteDevFromSceneAndLinkage(pRam->index);
					setNodeRemoveDetectedEvent(pRam->index);
					userDeleteOneDevFromRamAndFlash(pRam);
					gwStateForRealTime.echoNeedUpdateFlag = 1;//删除设备，重新update echo dev
					pRam = NULL;//删除设备后，pRam置为NULL
				}
                	}
                	break;
		  case UART_CMD_DEV_UPDATE_SHORT_ADDR_IDCT:
		  	printf("the dev node id was change ,it is update now\r\n");
		  	shortAddr = data[3] + ((uint16_t)data[4] << 8);
		  	memcpy(tempMac,&data[5],8);
		  	pRam = findInDevListByMac(tempMac);
	  		if(pRam == NULL)
			{
				printf("the update node is not in dev list\r\n");
			}else{
				pRam->shortAddr = shortAddr;
				userUpdateDevInfoDataToFlash(pRam);
			}
			break;
		  case UART_CMD_DEV_OFFLINE_IDCT:
		  	printf("set dev on off line\r\n");
		  	shortAddr = data[3] + ((uint16_t)data[4] << 8);
		  	pRam = findInDevListByNwkadd(shortAddr);
		  	if(pRam == NULL)
			{
				printf("the update node is not in dev list\r\n");
			}else{
				if(data[5])//上报的状态，1为离线，与wifi的协议相反
				{
					tempOnline = 0;
				}else{
					tempOnline = 1;
				}
				setNodeOnlineUpdateDetectedEvent(pRam,tempOnline);
				//(for working lixiong)上报app设备离线、上线
			}
		  	break;
		  default:  
       
                    break;
            }

            if(pRam != NULL)
            {
            		pRam->lastCommunicationTimes = gwStateForRealTime.sysRealTimeFors;
            		if(pRam->onOffLineState != 0)//清除读取指令标志，如果读取指令标志不为0，再次进入check函数时，则直接置该设备离线
            		{
				pRam->onOffLineState = 0;
            		}
			if(pRam->onLine == 0)//offline
			{
				printf("on line for dev uart rcv cmd\r\n");
				tempOnline = 1;
				setNodeOnlineUpdateDetectedEvent(pRam,tempOnline);
			}
            }
        }
    }
}

static void transportUartHexDataForHeart(UART_TX_CMD_BUF buff)
{
    uint8_t *transportBuf = (uint8_t *)mem_alloc(5);
    uint8_t transportLen;
    if(transportBuf == NULL)
    {
        printf("sys malloc mem was faild\r\n");
        return;
    }
   

    transportBuf[0] = 0xfa;//包头
    transportBuf[1] = 2;
    transportBuf[2] = buff.inCmd;
    transportBuf[3] = 5;//保留
    transportBuf[4] = calcFCS(&transportBuf[3],1);//payload 异或和
    transportBuf[5] = 0xf5;//包尾
    transportLen = 6;
    userUartSendWithDebugFunc(transportBuf,transportLen);
    
    if(transportBuf != NULL)
    {
        mem_free(transportBuf);
        transportBuf = NULL;
    }
}


//ZIGBB 入网指令发送
static void transportUartHexDataForPermitJoin(UART_TX_CMD_BUF buff)
{
    uint8_t *transportBuf = (uint8_t *)mem_alloc(6);
    uint8_t transportLen;
    int ret;
    if(transportBuf == NULL)
    {
        printf("sys malloc mem was faild\r\n");
        return;
    }
    if(buff.inPayload.inData == NULL)
    {
        printf("send uart in data was null\r\n");
        if(transportBuf != NULL)
        {
            mem_free(transportBuf);
            transportBuf = NULL;
        }
        return;
    }

    transportBuf[0] = 0xfa;//包头
    transportBuf[1] = 2;
    transportBuf[2] = buff.inCmd;
    transportBuf[3] = buff.inPayload.inData[0];
    transportBuf[4] = calcFCS(&transportBuf[3],1);//payload 异或和
    transportBuf[5] = 0xf5;//包尾
    transportLen = 6;
    ret = userUartSendWithDebugFunc(transportBuf,transportLen);
    printf("ret:%d\r\n",ret);
    if(ret == 0)//(qca_uart_send(transportBuf,transportLen) == 0)//success
    {
	fillUartCmdMonitor(buff.inCmd,buff.dstAddr,buff.dstEp,transportBuf,transportLen);
    }
    
    if(transportBuf != NULL)
    {
        mem_free(transportBuf);
        transportBuf = NULL;
    }
}

static void transportUartHexDataForSetZcToFactory(UART_TX_CMD_BUF buff)
{
    uint8_t *transportBuf = (uint8_t *)mem_alloc(6);
    uint8_t transportLen;
    int ret;
    if(transportBuf == NULL)
    {
        printf("sys malloc mem was faild\r\n");
        return;
    }
    if(buff.inPayload.inData == NULL)
    {
        printf("send uart in data was null\r\n");
        if(transportBuf != NULL)
        {
            mem_free(transportBuf);
            transportBuf = NULL;
        }
        return;
    }

    transportBuf[0] = 0xfa;//包头
    transportBuf[1] = 2;
    transportBuf[2] = buff.inCmd;
    transportBuf[3] = ~buff.inCmd;
    transportBuf[4] = calcFCS(&transportBuf[3],1);//payload 异或和
    transportBuf[5] = 0xf5;//包尾
    transportLen = 6;
    ret = userUartSendWithDebugFunc(transportBuf,transportLen);
    printf("ret:%d\r\n",ret);
    if(ret == 0)//(qca_uart_send(transportBuf,transportLen) == 0)//success
    {
	fillUartCmdMonitor(buff.inCmd,buff.dstAddr,buff.dstEp,transportBuf,transportLen);
    }
    
    if(transportBuf != NULL)
    {
        mem_free(transportBuf);
        transportBuf = NULL;
    }
}

static void transportUartHexDataForUpdateZc(UART_TX_CMD_BUF buff)
{
    uint8_t *transportBuf = (uint8_t *)mem_alloc(6);
    uint8_t transportLen;
    if(transportBuf == NULL)
    {
        printf("sys malloc mem was faild\r\n");
        return;
    }
    if(buff.inPayload.inData == NULL)
    {
        printf("send uart in data was null\r\n");
        if(transportBuf != NULL)
        {
            mem_free(transportBuf);
            transportBuf = NULL;
        }
        return;
    }

    transportBuf[0] = 0xfa;//包头
    transportBuf[1] = 2;
    transportBuf[2] = buff.inCmd;
    transportBuf[3] = buff.inPayload.inData[0];
    transportBuf[4] = calcFCS(&transportBuf[3],1);//payload 异或和
    transportBuf[5] = 0xf5;//包尾
    transportLen = 6;
    userUartSendWithDebugFunc(transportBuf,transportLen);

    
    if(transportBuf != NULL)
    {
        mem_free(transportBuf);
        transportBuf = NULL;
    }
}

static void transportUartHexDataForLeaveNode(UART_TX_CMD_BUF buff)
{
    uint8_t *transportBuf = (uint8_t *)mem_alloc(16);
    uint8_t transportLen;
    int ret;
    HM_DEV_RAM_LIST *pRam = NULL;
    
    if(transportBuf == NULL)
    {
        printf("sys malloc mem was faild\r\n");
        return;
    }
    if(buff.inPayload.inData == NULL)
    {
        printf("send uart in data was null\r\n");
        if(transportBuf != NULL)
        {
            mem_free(transportBuf);
            transportBuf = NULL;
        }
        return;
    }
    pRam = findInDevListByNwkadd(buff.dstAddr);
    if(pRam == NULL)
    {
	printf("the leave dev short addr was not in dev list\r\n");
	return;
    }
    transportBuf[0] = 0xfa;//包头
    transportBuf[1] = 12;
    transportBuf[2] = buff.inCmd;
    memcpy(&transportBuf[3],pRam->mac,8);
    transportBuf[11] = 0;
    transportBuf[12] = buff.dstAddr & 0xff;
    transportBuf[13] = (buff.dstAddr >> 8) & 0xff;
    transportBuf[14] = calcFCS(&transportBuf[3],11);//payload 异或和
    transportBuf[15] = 0xf5;//包尾
    transportLen = 16;
    ret = userUartSendWithDebugFunc(transportBuf,transportLen);
    printf("ret:%d\r\n",ret);
    if(ret == 0)//(qca_uart_send(transportBuf,transportLen) == 0)//success
    {
	fillUartCmdMonitor(buff.inCmd,buff.dstAddr,buff.dstEp,transportBuf,transportLen);
    }
    userDeleteOneDevFromRamAndFlash(pRam);//清除ram 和flash
    if(transportBuf != NULL)
    {
        mem_free(transportBuf);
        transportBuf = NULL;
    }
}


static void transportUartHexDataForCutRgb(UART_TX_CMD_BUF buff)
{
    uint8_t *transportBuf = (uint8_t *)mem_alloc(12);
    uint8_t transportLen;
    uint8_t cplen = 0;
    if(transportBuf == NULL)
    {
        printf("sys malloc mem was faild\r\n");
        return;
    }
    if(buff.inPayload.inData == NULL)
    {
        printf("send uart in data was null\r\n");
        if(transportBuf != NULL)
        {
            mem_free(transportBuf);
            transportBuf = NULL;
        }
        return;
    }

    transportBuf[0] = 0xfa;//包头
    transportBuf[2] = buff.inCmd;
    transportBuf[3] = buff.dstAddr & 0xff;
    transportBuf[4] = (buff.dstAddr >> 8) & 0xff;
    transportBuf[5] = buff.dstEp;
    transportBuf[6] = ZCL_RGBLIGHT_CLUSTER_ID & 0xff;
    transportBuf[7] = (ZCL_RGBLIGHT_CLUSTER_ID >> 8) & 0xff;
    transportBuf[8] = buff.inPayload.inData[0];
    if(transportBuf[8] == 0)//brightness control
    {
	transportBuf[9] = buff.inPayload.inData[1];
	cplen = 1;
	transportBuf[1] = 8;//lenth
    }else{
	transportBuf[9] = buff.inPayload.inData[1];
	transportBuf[10] = buff.inPayload.inData[2];
	cplen = 2;
	transportBuf[1] = 9;//lenth
    }
    transportBuf[9 + cplen] = calcFCS(&transportBuf[3],6 + cplen);//payload 异或和
    transportBuf[10 + cplen] = 0xf5;//包尾
    transportLen = 11 + cplen;
    if(userUartSendWithDebugFunc(transportBuf,transportLen) == 0)//success
    {
	fillUartCmdMonitor(buff.inCmd,buff.dstAddr,buff.dstEp,transportBuf,transportLen);
    }
    
    if(transportBuf != NULL)
    {
        mem_free(transportBuf);
        transportBuf = NULL;
    }
}

static void transportUartHexDataForOnOff(UART_TX_CMD_BUF buff)
{
    uint8_t *transportBuf = (uint8_t *)mem_alloc(12);
    uint8_t transportLen;
    if(transportBuf == NULL)
    {
        printf("sys malloc mem was faild\r\n");
        return;
    }
    if(buff.inPayload.inData == NULL)
    {
        printf("send uart in data was null\r\n");
        if(transportBuf != NULL)
        {
            mem_free(transportBuf);
            transportBuf = NULL;
        }
        return;
    }

    transportBuf[0] = 0xfa;//包头
    transportBuf[1] = 7;
    transportBuf[2] = buff.inCmd;
    transportBuf[3] = buff.dstAddr & 0xff;
    transportBuf[4] = (buff.dstAddr >> 8) & 0xff;
    transportBuf[5] = buff.dstEp;
    transportBuf[6] = ZCL_ON_OFF_CLUSTER_ID & 0xff;
    transportBuf[7] = (ZCL_ON_OFF_CLUSTER_ID >> 8) & 0xff;
    transportBuf[8] = buff.inPayload.inData[0];
    transportBuf[9] = calcFCS(&transportBuf[3],6);//payload 异或和
    transportBuf[10] = 0xf5;//包尾
    transportLen = 11;
    if(userUartSendWithDebugFunc(transportBuf,transportLen) == 0)//success
    {
	fillUartCmdMonitor(buff.inCmd,buff.dstAddr,buff.dstEp,transportBuf,transportLen);
    }
    
    if(transportBuf != NULL)
    {
        mem_free(transportBuf);
        transportBuf = NULL;
    }
}

static void transportUartHexDataForWriteAttribute(UART_TX_CMD_BUF buff)
{
	uint8_t *transportBuf = (uint8_t *)mem_alloc(25);
	uint8_t transportLen;
	if(transportBuf == NULL)
	{
		printf("sys malloc mem was faild\r\n");
		return;
	}
	if(buff.inPayload.inData == NULL)
	{
		printf("send uart in data was null\r\n");
		if(transportBuf != NULL)
		{
		    mem_free(transportBuf);
		    transportBuf = NULL;
		}
		return;
	}

	transportBuf[0] = 0xfa;//包头
	transportBuf[1] = 4 + buff.inPayload.inDataLen;
	transportBuf[2] = buff.inCmd;
	transportBuf[3] = buff.dstAddr & 0xff;
	transportBuf[4] = (buff.dstAddr >> 8) & 0xff;
	transportBuf[5] = buff.dstEp;
	memcpy(&transportBuf[6],&buff.inPayload.inData[0],buff.inPayload.inDataLen);
	transportBuf[6 + buff.inPayload.inDataLen] = calcFCS(&transportBuf[3],3 + buff.inPayload.inDataLen);//payload 异或和
	transportBuf[7 + buff.inPayload.inDataLen] = 0xf5;//包尾
	transportLen = 8 + buff.inPayload.inDataLen;
	if(userUartSendWithDebugFunc(transportBuf,transportLen) == 0)//success
	{
		fillUartCmdMonitor(buff.inCmd,buff.dstAddr,buff.dstEp,transportBuf,transportLen);
	}

	if(transportBuf != NULL)
	{
		mem_free(transportBuf);
		transportBuf = NULL;
	}
}


static void transportUartHexDataForReadAttribute(UART_TX_CMD_BUF buff)
{
	uint8_t *transportBuf = (uint8_t *)mem_alloc(25);
	uint8_t transportLen;
	if(transportBuf == NULL)
	{
		printf("sys malloc mem was faild\r\n");
		return;
	}
	if(buff.inPayload.inData == NULL)
	{
		printf("send uart in data was null\r\n");
		if(transportBuf != NULL)
		{
		    mem_free(transportBuf);
		    transportBuf = NULL;
		}
		return;
	}

	transportBuf[0] = 0xfa;//包头
	transportBuf[1] = 4 + buff.inPayload.inDataLen;
	transportBuf[2] = buff.inCmd;
	transportBuf[3] = buff.dstAddr & 0xff;
	transportBuf[4] = (buff.dstAddr >> 8) & 0xff;
	transportBuf[5] = buff.dstEp;
	memcpy(&transportBuf[6],&buff.inPayload.inData[0],buff.inPayload.inDataLen);
	transportBuf[6 + buff.inPayload.inDataLen] = calcFCS(&transportBuf[3],3 + buff.inPayload.inDataLen);//payload 异或和
	transportBuf[7 + buff.inPayload.inDataLen] = 0xf5;//包尾
	transportLen = 8 + buff.inPayload.inDataLen;
	userUartSendWithDebugFunc(transportBuf,transportLen) ;
	

	if(transportBuf != NULL)
	{
		mem_free(transportBuf);
		transportBuf = NULL;
	}
}

static void transportUartHexDataForOnOffControlByGroupsOrBroadcast(UART_TX_CMD_BUF buff)
{
    uint8_t *transportBuf = (uint8_t *)mem_alloc(12);
    uint8_t transportLen;
    if(transportBuf == NULL)
    {
        printf("sys malloc mem was faild\r\n");
        return;
    }
    if(buff.inPayload.inData == NULL)
    {
        printf("send uart in data was null\r\n");
        if(transportBuf != NULL)
        {
            mem_free(transportBuf);
            transportBuf = NULL;
        }
        return;
    }

    transportBuf[0] = 0xfa;//包头
    transportBuf[1] = 7;
    transportBuf[2] = buff.inCmd;
    transportBuf[3] = buff.dstEp;
    transportBuf[4] = buff.dstAddr & 0xff;
    transportBuf[5] = (buff.dstAddr >> 8) & 0xff;
    transportBuf[6] = ZCL_ON_OFF_CLUSTER_ID & 0xff;
    transportBuf[7] = (ZCL_ON_OFF_CLUSTER_ID >> 8) & 0xff;
    transportBuf[8] = buff.inPayload.inData[0];
    transportBuf[9] = calcFCS(&transportBuf[3],6);//payload 异或和
    transportBuf[10] = 0xf5;//包尾
    transportLen = 11;
    if(userUartSendWithDebugFunc(transportBuf,transportLen) == 0)//success
    {
	fillUartCmdMonitor(buff.inCmd,buff.dstAddr,buff.dstEp,transportBuf,transportLen);
    }
    
    if(transportBuf != NULL)
    {
        mem_free(transportBuf);
        transportBuf = NULL;
    }
}

static void transportUartHexDataForReadNodeInfo(UART_TX_CMD_BUF buff)
{
    uint8_t *transportBuf = (uint8_t *)mem_alloc(7);
    uint8_t transportLen;
    if(transportBuf == NULL)
    {
        printf("sys malloc mem was faild\r\n");
        return;
    }
    if(buff.inPayload.inData == NULL)
    {
        printf("send uart in data was null\r\n");
        if(transportBuf != NULL)
        {
            mem_free(transportBuf);
            transportBuf = NULL;
        }
        return;
    }

    transportBuf[0] = 0xfa;//包头
    transportBuf[1] = 3;
    transportBuf[2] = buff.inCmd;
    transportBuf[3] = buff.dstAddr & 0xff;
    transportBuf[4] = (buff.dstAddr >> 8) & 0xff;
    transportBuf[5] = calcFCS(&transportBuf[3],2);//payload 异或和
    transportBuf[6] = 0xf5;//包尾
    transportLen = 7;
    userUartSendWithDebugFunc(transportBuf,transportLen);//success
    
    
    if(transportBuf != NULL)
    {
        mem_free(transportBuf);
        transportBuf = NULL;
    }
}

static void transportUartHexDataForReadZCInfo(UART_TX_CMD_BUF buff)
{
    uint8_t *transportBuf = (uint8_t *)mem_alloc(6);
    uint8_t transportLen;
    if(transportBuf == NULL)
    {
        printf("sys malloc mem was faild\r\n");
        return;
    }
    if(buff.inPayload.inData == NULL)
    {
        printf("send uart in data was null\r\n");
        if(transportBuf != NULL)
        {
            mem_free(transportBuf);
            transportBuf = NULL;
        }
        return;
    }

    transportBuf[0] = 0xfa;//包头
    transportBuf[1] = 2;
    transportBuf[2] = buff.inCmd;
    transportBuf[3] = ~buff.inCmd;
    transportBuf[4] = calcFCS(&transportBuf[3],1);//payload 异或和
    transportBuf[5] = 0xf5;//包尾
    transportLen = 6;
    userUartSendWithDebugFunc(transportBuf,transportLen);//success
    
    
    if(transportBuf != NULL)
    {
        mem_free(transportBuf);
        transportBuf = NULL;
    }
}

static void transportUartHexDataForLevel(UART_TX_CMD_BUF buff)
{
    uint8_t *transportBuf = (uint8_t *)mem_alloc(10 + buff.inPayload.inDataLen);
    uint8_t transportLen;
    if(transportBuf == NULL)
    {
        printf("sys malloc mem was faild\r\n");
        return;
    }
    if(buff.inPayload.inData == NULL)
    {
        printf("send uart in data was null\r\n");
        if(transportBuf != NULL)
        {
            mem_free(transportBuf);
            transportBuf = NULL;
        }
        return;
    }

    transportBuf[0] = 0xfa;//包头
    transportBuf[1] = buff.inPayload.inDataLen + 6;
    transportBuf[2] = buff.inCmd;
    transportBuf[3] = buff.dstAddr & 0xff;
    transportBuf[4] = (buff.dstAddr >> 8) & 0xff;
    transportBuf[5] = buff.dstEp;
    transportBuf[6] = ZCL_LEVEL_CONTROL_CLUSTER_ID & 0xff;
    transportBuf[7] = (ZCL_LEVEL_CONTROL_CLUSTER_ID >> 8) & 0xff;
    memcpy(&transportBuf[8],buff.inPayload.inData,buff.inPayload.inDataLen);
    transportBuf[8 + buff.inPayload.inDataLen] = calcFCS(&transportBuf[3],buff.inPayload.inDataLen + 5);//payload 异或和
    transportBuf[9 + buff.inPayload.inDataLen] = 0xf5;//包尾
    transportLen = 10 + buff.inPayload.inDataLen;
    if(userUartSendWithDebugFunc(transportBuf,transportLen) == 0)//success
    {
	fillUartCmdMonitor(buff.inCmd,buff.dstAddr,buff.dstEp,transportBuf,transportLen);
    }
    
    if(transportBuf != NULL)
    {
        mem_free(transportBuf);
        transportBuf = NULL;
    }
}

static void transportUartHexDataForWDControl(UART_TX_CMD_BUF buff)
{
    uint8_t *transportBuf = (uint8_t *)mem_alloc(10 + buff.inPayload.inDataLen);
    uint8_t transportLen;
    if(transportBuf == NULL)
    {
        printf("sys malloc mem was faild\r\n");
        return;
    }
    if(buff.inPayload.inData == NULL)
    {
        printf("send uart in data was null\r\n");
        if(transportBuf != NULL)
        {
            mem_free(transportBuf);
            transportBuf = NULL;
        }
        return;
    }

    transportBuf[0] = 0xfa;//包头
    transportBuf[1] = buff.inPayload.inDataLen + 6;
    transportBuf[2] = buff.inCmd;
    transportBuf[3] = buff.dstAddr & 0xff;
    transportBuf[4] = (buff.dstAddr >> 8) & 0xff;
    transportBuf[5] = buff.dstEp;
    transportBuf[6] = ZCL_IAS_WD_CLUSTER_ID & 0xff;
    transportBuf[7] = (ZCL_IAS_WD_CLUSTER_ID >> 8) & 0xff;
    memcpy(&transportBuf[8],buff.inPayload.inData,buff.inPayload.inDataLen);
    transportBuf[8 + buff.inPayload.inDataLen] = calcFCS(&transportBuf[3],buff.inPayload.inDataLen + 5);//payload 异或和
    transportBuf[9 + buff.inPayload.inDataLen] = 0xf5;//包尾
    transportLen = 10 + buff.inPayload.inDataLen;
    if(userUartSendWithDebugFunc(transportBuf,transportLen) == 0)//success
    {
	fillUartCmdMonitor(buff.inCmd,buff.dstAddr,buff.dstEp,transportBuf,transportLen);
    }
    
    if(transportBuf != NULL)
    {
        mem_free(transportBuf);
        transportBuf = NULL;
    }
}

static void transportUartHexDataForColorControl(UART_TX_CMD_BUF buff)
{
    uint8_t *transportBuf = (uint8_t *)mem_alloc(10 + buff.inPayload.inDataLen);
    uint8_t transportLen;
    if(transportBuf == NULL)
    {
        printf("sys malloc mem was faild\r\n");
        return;
    }
    if(buff.inPayload.inData == NULL)
    {
        printf("send uart in data was null\r\n");
        if(transportBuf != NULL)
        {
            mem_free(transportBuf);
            transportBuf = NULL;
        }
        return;
    }

    transportBuf[0] = 0xfa;//包头
    transportBuf[1] = buff.inPayload.inDataLen + 6;
    transportBuf[2] = buff.inCmd;
    transportBuf[3] = buff.dstAddr & 0xff;
    transportBuf[4] = (buff.dstAddr >> 8) & 0xff;
    transportBuf[5] = buff.dstEp;
    transportBuf[6] = ZCL_COLOR_CONTROL_CLUSTER_ID & 0xff;
    transportBuf[7] = (ZCL_COLOR_CONTROL_CLUSTER_ID >> 8) & 0xff;
    memcpy(&transportBuf[8],buff.inPayload.inData,buff.inPayload.inDataLen);
    transportBuf[8 + buff.inPayload.inDataLen] = calcFCS(&transportBuf[3],buff.inPayload.inDataLen + 5);//payload 异或和
    transportBuf[9 + buff.inPayload.inDataLen] = 0xf5;//包尾
    transportLen = 10 + buff.inPayload.inDataLen;
    if(userUartSendWithDebugFunc(transportBuf,transportLen) == 0)//success
    {
	fillUartCmdMonitor(buff.inCmd,buff.dstAddr,buff.dstEp,transportBuf,transportLen);
    }
    
    if(transportBuf != NULL)
    {
        mem_free(transportBuf);
        transportBuf = NULL;
    }
}

void userManageUartCmdMonitor(void)
{
	uint32_t tempTime100ms = time_ms() / 100;//qcom_time_us() / 100000 ;
	uint8_t i;
	for(i = 0; i < MAX_UART_CMD_MONITOR_NUM; i ++)
	{
		if(uartCmdMonito[i].validFlag == 1)
		{
			if(tempTime100ms > uartCmdMonito[i].sendTime100Ms )
			{
				if(tempTime100ms - uartCmdMonito[i].sendTime100Ms > 25)// 2.5s
				{
					if(uartCmdMonito[i].sendCount < 2)
					{
						printf("monitor resend the cmd\r\n");
						qca_uart_send(uartCmdMonito[i].cmdbk.bkBuff,uartCmdMonito[i].cmdbk.bkLen);
						uartCmdMonito[i].sendCount ++;
						uartCmdMonito[i].sendTime100Ms = tempTime100ms;
					}else{
						printf("monitor delete the cmd\r\n");
						deleteUartCmdMonitor(i);
					}
				}
			}else{
				uartCmdMonito[i].sendTime100Ms = tempTime100ms;
			}
		}
	}
}

void uartTxDataCmdDeal(void)
{
    uint8_t i = 0;
    uint8_t index;
    do{
        index = userFromInFineValidUartTxBufIndex(i);
        if(index < MAX_UART_TX_CMD_BUF_NUM)
        {
            switch(uartTXCmd[index].inCmd)
            {
                case UART_CMD_PERMIT_JOIN_REQ:
                	printf("tx for permit join\r\n");
                	transportUartHexDataForPermitJoin(uartTXCmd[index]);
                	break;
                case UART_CMD_SEND_ZC_HEART_REQ:
                	printf("tx for heart\r\n");
                	transportUartHexDataForHeart(uartTXCmd[index]);
                	break;
                case UART_CMD_DEV_INFO_REQ:
                	printf("tx for read dev info\r\n");
                	transportUartHexDataForReadNodeInfo(uartTXCmd[index]);
                	break;
                case UART_CMD_READ_ZC_INFO_REQ:
                	printf("tx for read zc info\r\n");
                	transportUartHexDataForReadZCInfo(uartTXCmd[index]);
                	break;
                case UART_CMD_LEAVE_DEV_REQ:
                	printf("tx for leave node\r\n");
                	transportUartHexDataForLeaveNode(uartTXCmd[index]);
                	break;
                case UART_CMD_UPDATE_ZC_SOFT_REQ:
                	printf("tx for update zc program\r\n");
                	transportUartHexDataForUpdateZc(uartTXCmd[index]);//串口发送更新固件指令
                	qcom_thread_msleep(1000);//等待1s后再发送开始升级指令
                	uartSendXmodemStartOTA();
                	break;
                case UART_CMD_WRITE_ATTR_REQ:
                	printf("tx for write attr\r\n");
                	transportUartHexDataForWriteAttribute(uartTXCmd[index]);
                	break;
                case UART_CMD_READ_ATTR_REQ:
                	printf("tx for read attr\r\n");
                	transportUartHexDataForReadAttribute(uartTXCmd[index]);
                	break;
                case UART_CMD_GET_ACTIVE_EP_REQ:
                	break;
                case UART_CMD_GET_EP_SMPDST_REQ:
                	break;
                case UART_CMD_CFG_ATTR_REPORT_REQ:
                	break;
                case UART_CMD_GET_NODE_DESCRIPTOR_REQ:
                	break;
                case UART_CMD_SET_ZC_TO_FACTORY_REQ:
                	transportUartHexDataForSetZcToFactory(uartTXCmd[index]);
                	break;
                case UART_CMD_ONOFF_CONTROL_REQ:
                	printf("tx for on off\r\n");
                      transportUartHexDataForOnOff(uartTXCmd[index]);
                      break;
                case UART_CMD_LEVEL_CONTROL_REQ:
                	printf("tx for level control\r\n");
                	transportUartHexDataForLevel(uartTXCmd[index]);
                	break;
                case UART_CMD_WD_CONTROL_REQ:
                	printf("tx for wd control\r\n");
                	transportUartHexDataForWDControl(uartTXCmd[index]);
                	break;
                case UART_CMD_IDENTIFY_REQ:
                    break;
                case UART_CMD_COLOR_CONTROL_REQ:
                	printf("tx for color control\r\n");
                	transportUartHexDataForColorControl(uartTXCmd[index]);
                	break;
                case UART_CMD_ONOFF_CONTROL_BY_GROUP_REQ:
                	printf("tx for on off control by groups\r\n");
                	transportUartHexDataForOnOffControlByGroupsOrBroadcast(uartTXCmd[index]);
                	break;
                case UART_CMD_RGBLIGHT_CONTROL_REQ:
                	printf("tx for cut rgb 4 control\r\n");
                	transportUartHexDataForCutRgb(uartTXCmd[index]);
                	break;
                default:
                    break;
            }
            userClearValidUartTxBufIndex(index);
        }
        i = index;
        qcom_thread_msleep(50);//qcom_thread_msleep(20);
    }while(i < MAX_UART_TX_CMD_BUF_NUM); 
}




int hm_uart_reslove_packet(unsigned char **packet_start, unsigned char **packet_end, 	unsigned char *buf, int buf_len, unsigned char *data_start, unsigned char *data_end)
{	
	if (qca_uart_get_buf_full_status())	
	{	
		printf("the uart buff was full");
		return -3;	
	}	// 
TODO:	
	if (data_end >= data_start)	
	{		
		if (data_end - data_start < UART_PACKET_BASIC_LEN)		
		{			
			return -1;		
		}	
	}else{		
		if (buf_len - (data_start - data_end) < UART_PACKET_BASIC_LEN)		
		{			
			return -1;		
		}	
	}	
	*packet_start	= data_start;	
	*packet_end		= data_end-1;	
	return 0;
}

void checkMemIsOk(uint8_t *data,uint8_t len)
{
	uint8_t i;
	static uint8_t j = 0;
	j ++;
	printf("enter checkMemIsOk:%d\r\n",j);
	if(data == NULL)
	{
		printf("the input data points was null\r\n");
		return;
	}
	for(i = 0; i < len; i ++)
	{
		if(data[i] != 0)
		{
			printf("the mem is not zero\r\n");
		}
	}
}

void hm_uart_work_task(unsigned int arg)
{
	uint32_t sysTime100ms;
	int		ret, len;
	int 		i,tempLen;
	uint8_t monitorTime = 0;
	//uint8_t zbSysStartFlag = 2;


	uint64_t temp1 ;
	uint32_t temp ;
	printf("read zc info now\r\n");
	qcom_thread_msleep(1000);//等待beep线程中gpio init完
	qca_gpio_set_pin_status(ZIGBEE_RESET,1);
	qcom_thread_msleep(1000);
	
	userFillUartCmdForReadZCnfo();//填充buf但是不会发送出去，当检测到zigbee app start后才会相应uart发送函数
	while (1)
	{
		//== receive one packet
		memset(uartRXData[0].data, 0, MAX_UART_RX_BUF_LENTH);
		ret = qca_uart_get_one_recv_packet((unsigned char *)uartRXData[0].data, &len);
		if (ret < 0)
		{
			;//printf("uart not have data receive");		// not any message
		}else{
			uartRXData[0].data[len] = '\0';
			printf("uart receive %d data",len);
			if(len == 1)
			{
				printf("%d\r\n",uartRXData[0].data[0]);
				//if(otaStationInfo.devUpdateNeedFlag != NO_DEV_NEED_UPDATE_IMAGE)
				{
					if(devOtaUpdateingFlag == 0)
					{
						if((uartRXData[0].data[0] == XMODEM_NAK) || (uartRXData[0].data[0] == 'C'))
						{
							userOtaZigbeeGWCheck ++;
							if(userOtaZigbeeGWCheck >= 2)
							{
								if(otaStationInfo.firmwareValid == 1)
								{
									otaStationInfo.needDownloadImageFromCloud = 0;
									devOtaUpdateingFlag = 1;
									zcXmodemStation = XUSER_START;
								}else{
									otaStationInfo.needDownloadImageFromCloud = 1;
								}
							}
						}
					}else if(devOtaUpdateingFlag == 1){
						if(uartRXData[0].data[0] == XMODEM_ACK)
						{
							if(zcXmodemStation == XUSER_WAIT_COMMUNITE_ACK)
							{
								zcXmodemStation = XMODEM_ACK;
							}else if(zcXmodemStation == XUSER_WAIT_END_ACK){
								zcXmodemStation = XUSER_END;
							}
						}else if(uartRXData[0].data[0] == XMODEM_CAN){
							zcXmodemStation = XMODEM_CAN;	
						}else if(uartRXData[0].data[0] == XMODEM_NAK){
							zcXmodemStation = XMODEM_NAK;	
						}
					}
				}
	
			}else{
				printf("print uart rcv hex:\r\n");
				for(i = 0; i < len; i ++)
				{
					printf("%02x ",uartRXData[0].data[i]);
				}
				printf("\r\n");

				do{

					// 判断ZC firmware OTA完成，需要start app
					if((zcXmodemStation == XUSER_END) || (XUSER_WAIT_END_ACK == zcXmodemStation))
					{
						if(strstr(uartRXData[0].data,"Serial upload complete") != NULL)
						{
							zcXmodemStation = XUSER_RESTART_APP;
							break;
						}
					}

					if(zbSysStartFlag != 0)
					{
						if(strstr(uartRXData[0].data,"zb app start") != NULL)
						{
							printf("zb app check ok\r\n");
							zbSysStartFlag = 0;//zigbee 模块上有app程序
							break;
						}
					}

					userOtaZigbeeGWCheck  = 0;//清除确认OTA指令计数器
					for(i = 0; i < len; i ++)
					{
						if(uartRXData[0].data[i] == UART_DATA_HEAD)
						{
							if((uartRXData[0].data[i + 1] < MAX_UART_RX_BUF_LENTH -3) && (uartRXData[0].data[i + 1] >= 2))
							{
								tempLen = uartRXData[0].data[i + 1];
								if( uartRXData[0].data[i + tempLen + 3] == UART_DATA_END)
								{
									//备注: 需要在uart OTA完了后发送一帧心跳数据，以确保ZC成功启动
									sysTime100ms = time_ms() / 100;//qcom_time_us() / 100000;
									uartHeartManage.lastCommuTime100ms = sysTime100ms;//心跳管理，跟新心跳计时器
									uartHeartManage.uartWorkDataType = UART_WORK_COMMUNICATION;
									uartRcvDataDeal( &uartRXData[0].data[i],tempLen + 4);
									i += tempLen + 3;
								}
							}
						}
					}

					/*uint16_t r,g,b,x,y;
					uint8_t level;
					if((uartRXData[0].data[0] == 0x55) && (len >= 2))
					{
						x = uartRXData[0].data[1] + (uartRXData[0].data[2] << 8);
						y = uartRXData[0].data[3] + (uartRXData[0].data[4] << 8);
						level = uartRXData[0].data[5];
						 hmzColorXYToRgb(x,y,level,&r,&g,&b);
						 printf("test for rgb,r:%d,g:%d,b:%d,x:%d,y:%d,l:%d\r\n",r,g,b,x,y,level);
					}*/

					/*uint16_t r_value,g_value,b_value;
					uint8_t tempLed = 0;
					if((uartRXData[0].data[0] == 0x55) && (len >= 2))
					{
						r_value = uartRXData[0].data[1] * 50;
						g_value = uartRXData[0].data[2] * 50;
						b_value = uartRXData[0].data[3] * 50;
						printf("r:%d\r\ng:%d\r\nb:%d\r\n",r_value,g_value,b_value);
						if(r_value != 0)
						{
							tempLed |= PWM_PORT_R;
						}
						if(g_value != 0)
						{
							tempLed |= PWM_PORT_G;
						}
						if(b_value != 0)
						{
							tempLed |= PWM_PORT_B;
						}
						qcom_pwm_control(0, 0, PWM_PORT_R | PWM_PORT_G | PWM_PORT_B);
						qcom_pwm_port_set(100000, r_value, 0, PWM_R, 2);
						qcom_pwm_port_set(100000, g_value, 0, PWM_G, 2);
						qcom_pwm_port_set(100000, b_value, 0, PWM_B, 2);
						qcom_pwm_control(0, 1, PWM_PORT_R | PWM_PORT_G | PWM_PORT_B);
						if( uartRXData[0].data[2] == 1)
						{
							gwStateForRealTime.gwIsAlarning = 1;
						}else if( uartRXData[0].data[2] == 2){
							gwStateForRealTime.gwIsAlarning = 0;
							gwStateForRealTime.gwDevIsOta = 1;
						}else if( uartRXData[0].data[2] == 3){
							gwStateForRealTime.gwIsAlarning = 0;
							gwStateForRealTime.gwDevIsOta = 2;
						}else if( uartRXData[0].data[2] == 4){
							gwStateForRealTime.gwIsAlarning = 0;
							gwStateForRealTime.gwDevIsOta = 0;
							gwStateForRealTime.gwZbIsJoining = 3;
						}else if( uartRXData[0].data[2] == 5){
							gwStateForRealTime.gwIsAlarning = 0;
							gwStateForRealTime.gwDevIsOta = 0;
							gwStateForRealTime.gwZbIsJoining = 1;
						}else if( uartRXData[0].data[2] == 6){
							gwStateForRealTime.gwIsAlarning = 0;
							gwStateForRealTime.gwDevIsOta = 0;
							gwStateForRealTime.gwZbIsJoining = 0;
							hmIotsDevInfo.light_onoff = 1;
						}else if( uartRXData[0].data[2] == 7){
							gwStateForRealTime.gwIsAlarning = 0;
							gwStateForRealTime.gwDevIsOta = 0;
							gwStateForRealTime.gwZbIsJoining = 0;
							hmIotsDevInfo.light_onoff = 0;
						}
					}*/

					
					/*uint8_t test[512];
					uint16_t testlen;
					if(uartRXData[0].data[0] == '^')
					{
						printf("test for permit join time:%d",uartRXData[0].data[1]);
						userFillUartCmdForPermitJoin(uartRXData[0].data[1]);
						//user_aes_decode(&uartRXData[0].data[1],len - 1,uartRXData[1].data);
						//memset(uartRXData[1].data,'\0',MAX_UART_RX_BUF_LENTH);
					}else{
						testlen = user_aes_encode(uartRXData[0].data,len,test);
						if(uartRXData[0].data[0] == '&')
						{
							DEV_MYSELF_INFO *tempDevInfo = &hmIotsDevInfo;
							tempDevInfo->wifiInfo.work_mode = 5;
						       qca_save_flash_params(FLASH_BASIC_ADDR + START_ADDR_FLASH_DEV_MYSELF_INFO_OFFSET, (unsigned char *)tempDevInfo, sizeof(DEV_MYSELF_INFO));
						       qcom_sys_reset();
						}
					}*/
				}while(0);
			}
		}

		if(devOtaUpdateingFlag == 0)//确保在OTA时不发送串口数据
		{
			if (zbSysStartFlag == 0)//第一次读取zc info，如果一直没有读到有效的串口数据，zbSysStartFlag一直等于1
			{
				uartTxDataCmdDeal();
				monitorTime ++;
				if(monitorTime >= 10)
				{
					monitorTime = 0;
					userManageUartHeart();
					userManageUartCmdMonitor();
				}
			}else{
				if(zbSysStartFlag == 2)
				{
					zbSysStartFlag = 1;
					uartSendXmodemStartOTA();
				}
			}
		}

		/*if(gwStateForRealTime.gwZbIsJoining == 0)////为了检测是否有设备入网，判断是否需要update echo list
		{
			if(zbJoinFlag == 1)
			{
				zbJoinFlag = 0;
				if(zbJoinDevNum > 0)
				{
					zbJoinDevNum = 0;
					gwStateForRealTime.echoNeedUpdateFlag = 1;
				}
			}
		}*///设备刚入网时名称无法被echo识别，所以在刚入网的时候没有必要上传echo列表
		qcom_thread_msleep(50);
	}
}

qcom_timer_t color_convert_timer;
NEWCOLORREPORT newColorReport;
void color_convert_timer_handle(unsigned int alarm, void *arg)
{
				

}
void uart_work_task_init(void)
{
	qcom_uart_para uart_para;
	uart_para.BaudRate = 115200;
	uart_para.number = 8;
	uart_para.StopBits = 1;
	uart_para.parity = 0;
	uart_para.FlowControl = 0;
	printf("enter uart work task init");
	clearUartCmdMonitor();
	userFlashInitToRam();

	//qcom_timer_init(&color_convert_timer, color_convert_timer_handle, NULL, 2000, ONESHOT);
	//qcom_timer_start(&color_convert_timer);
	printf("uart_work_task_init--------------01\n");
	if(qca_uart_task_start(&uart_para, 2048, hm_uart_reslove_packet) == 0)
	{
		printf("uart_work_task_init--------------02\n");
		// uart data handle task
		qca_task_start(hm_uart_work_task, 0, 4 * 4096);

		qcom_thread_msleep(100);
	}else{
		printf("init uart was fail");
	}
}
