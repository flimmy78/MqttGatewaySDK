#include "qcom_common.h"
#include "qca_json.h"
#include "hm_app.h"
#include "hm_zigbeeInfohand.h"
#include "qcom_uart.h"
#include "hm_otaDefine.h"
#include "hm_net_data_manage.h"
#include "hm_zigbeeStateDeal.h"
#include "hm_reportDevToCloud.h"
#include "hm_halBeep.h"
#include "hm_sceneAndLinkage.h"

extern DEV_MYSELF_INFO hmIotsDevInfo;
extern TX_SEMAPHORE beep_semaphore_ptr;
extern GWSTATFORTIME gwStateForRealTime;
extern BEEP_INFO beep_info;
extern HM_GW_LIST gw_info;
extern WIFICMDWATIRSP wifiCmdWaitRspBuf[SPECIALCMDNUM];



void hmzColorRgbToXY(uint16_t r, uint16_t g, uint16_t b, uint16_t *color_x, uint16_t *color_y, uint8_t *color_level)
{
	int l;
	float fx, fy;

	l=((r>g)?r:g);
	l=((l> b)?l:b);
	fx=(2.768892*r+1.751748*g+1.13016*b)/(3.768892*r+6.398956*g+6.784552*b);
	fy=(1*r+4.5907*g+0.0601*b)/(3.768892*r+6.398956*g+6.784552*b);
	
	*color_x=(uint16_t)(fx*0xffef);
	*color_y=(uint16_t)(fy*0xffef);
	*color_level=(uint8_t)(l>>8);
	if(*color_level >= 254)
		*color_level = 254;
}

void hmzColorXYToRgb(uint16_t color_x, uint16_t color_y, uint8_t color_level, uint16_t *red, uint16_t *green, uint16_t *blue)
{
	float x,y;
	float tmp,l;
	float r,g,b;
	float Dd=0,D1=0,D2=0,D3=0;  
	float a1=2.768892,b1=1.751748,c1=1.13016,a2=1, b2=4.5907, c2=0.0601;
	float /*a3=0, b3=0.056508, c3=5.594292,*/a4=3.768892,b4=6.398956,c4=6.784552;
	x = (float)color_x/0x0000ffef;
	y = (float)color_y/0x0000ffef;

	Dd=(a1-a4*x)*(b2-b4*y-c2+c4*y)+(b4*x-b1)*(a2-a4*y-c2+c4*y)+(c1-c4*x)*(a2-a4*y-b2+b4*y);
	D1=(b1-b4*x)*(c2-c4*y)-(c1-c4*x)*(b2-b4*y);
	D2=(c1-c4*x)*(a2-a4*y)-(a1-a4*x)*(c2-c4*y);
	D3=(a1-a4*x)*(b2-b4*y)-(b1-b4*x)*(a2-a4*y);

	r=D1/Dd;
	g=D2/Dd;
	b=D3/Dd;

	tmp=((r>g)?r:g);
	l=((tmp> b)?tmp:b);

	*red = (uint16_t)((float)color_level/l*r);
	*green = (uint16_t)((float)color_level/l*g);
	*blue = (uint16_t)((float)color_level/l*b);

	if(*red>=254)
		*red=255;
	if(*green>=254)
		*green=255;
	if(*blue>=254)
		*blue=255;

	*red *=256;
	*green *=256;
	*blue *=256;
}

void userDevLinkNightLight(HM_DEV_RAM_LIST *pni)
{
	uint8_t i;
	if((pni->devType == NODE_INFO_TYPE_MAGNET_DOOR) || (pni->devType == NODE_INFO_TYPE_PIR_SENSOR) || (pni->devType == NODE_INFO_TYPE_VIBRATION))
	{
		do{
			if(pni->epList[0].devData.zoneStateApp.alarms != ALARM)
			{
				break;
			}
			if(hmIotsDevInfo.gwLightForNight.enable == 1)
			{
				for(i = 0; i < MAX_HOME_ARM_FOR_SENSOR_NUM; i ++)
				{
					if(hmIotsDevInfo.gwLightForNight.index[i] == pni->index)
					{
						if((hmIotsDevInfo.light_onoff != 1) && (gwStateForRealTime.environment_lux == ENVIRONMENT_DARK))
						{
							hmIotsDevInfo.light_onoff = 2;
						}
						break;
					}
				}
			}
		}while(0);
	}
}
void hmSetAllSensorArm(void)
{
	HM_GW_LIST *pgw_info=&gw_info;
	HM_DEV_RAM_LIST *pni=(HM_DEV_RAM_LIST *)(pgw_info->pnode_list);
	HM_DEV_RAM_LIST *pni_tmp = pni;
	if (pni_tmp!= NULL)
	{
		do
		{
			if((pni_tmp->devType == NODE_INFO_TYPE_MAGNET_DOOR)||(pni_tmp->devType == NODE_INFO_TYPE_PIR_SENSOR) ||(pni_tmp->devType == NODE_INFO_TYPE_VIBRATION))
			{
				
				if(pni_tmp->epList[0].devData.zoneStateApp.armMode  != 1)
				{
					pni_tmp->epList[0].devData.zoneStateApp.armMode = 1;
					userUpdateDevInfoDataToFlash(pni_tmp);//保存到flash中
				}
				
			}
			pni_tmp=(HM_DEV_RAM_LIST*)pni_tmp->pnext_dev_info;
		}while (pni_tmp!=pni);
	}
	
}

void hmSetAllSensorHomeArm(void)
{
	HM_GW_LIST *pgw_info=&gw_info;
	HM_DEV_RAM_LIST *pni=(HM_DEV_RAM_LIST *)(pgw_info->pnode_list);
	HM_DEV_RAM_LIST *pni_tmp = pni;
	uint8_t i;
	if (pni!= NULL)
	{
		do
		{
			if((pni_tmp->devType == NODE_INFO_TYPE_MAGNET_DOOR) || (pni_tmp->devType == NODE_INFO_TYPE_PIR_SENSOR) ||(pni_tmp->devType == NODE_INFO_TYPE_VIBRATION))
			{
				
				for(i = 0; i < hmIotsDevInfo.home_arm_for_dev.indexNum; i ++)
				{
					if(pni_tmp->index == hmIotsDevInfo.home_arm_for_dev.index[i])
					{
						if(pni_tmp->epList[0].devData.zoneStateApp.armMode  != 1)
						{
							pni_tmp->epList[0].devData.zoneStateApp.armMode = 1;
							userUpdateDevInfoDataToFlash(pni_tmp);//保存到flash中
						}
						break;
					}
				}
				if(i == hmIotsDevInfo.home_arm_for_dev.indexNum)
				{
					if(pni_tmp->epList[0].devData.zoneStateApp.armMode  != 0)
					{
						pni_tmp->epList[0].devData.zoneStateApp.armMode = 0;
						userUpdateDevInfoDataToFlash(pni_tmp);//保存到flash中
					}
				}
				
			}
			pni_tmp=(HM_DEV_RAM_LIST*)pni_tmp->pnext_dev_info;
		}while (pni_tmp!=pni);
	}
	
}

void hmSetAllSensorDisarm(void)
{
	HM_GW_LIST *pgw_info=&gw_info;
	HM_DEV_RAM_LIST *pni=(HM_DEV_RAM_LIST *)(pgw_info->pnode_list);
	HM_DEV_RAM_LIST *pni_tmp = pni;
	if (pni_tmp!= NULL)
	{
		do
		{
			if((pni_tmp->devType == NODE_INFO_TYPE_MAGNET_DOOR)||(pni_tmp->devType == NODE_INFO_TYPE_PIR_SENSOR) ||(pni_tmp->devType == NODE_INFO_TYPE_VIBRATION))
			{
				
				if(pni_tmp->epList[0].devData.zoneStateApp.armMode  != 0)
				{
					pni_tmp->epList[0].devData.zoneStateApp.armMode = 0;
					userUpdateDevInfoDataToFlash(pni_tmp);//保存到flash中
				}
				
			}else if(pni_tmp->devType == NODE_INFO_TYPE_WARNING_DEV){
				userAppControlWDFunc(pni_tmp->shortAddr,pni_tmp->epList[0].ep,0,0);
			}
			pni_tmp=(HM_DEV_RAM_LIST*)pni_tmp->pnext_dev_info;
		}while (pni_tmp!=pni);
	}
}

void userDealWriteAttrCmdRspEvent(uint16_t shortAddr,uint16_t clusterId,uint8_t ep,uint8_t status)
{
	uint8_t i;
	uint8_t data[7];
	HM_DEV_RAM_LIST *pRam = findInDevListByNwkadd(shortAddr);
	if(pRam != NULL)
	{
		for(i = 0; i < SPECIALCMDNUM; i ++)
		{
			if(wifiCmdWaitRspBuf[i].valid == 1)
			{
				if(wifiCmdWaitRspBuf[i].zbCmd == UART_CMD_WRITE_ATTR_REQ)
				{
					if((clusterId == wifiCmdWaitRspBuf[i].zbClusterId) && (ep == wifiCmdWaitRspBuf[i].zbEp) && (shortAddr == wifiCmdWaitRspBuf[i].zbShortAddr))
					{
						data[0] = wifiCmdWaitRspBuf[i].cmdSn & 0xff;
						data[1] = (wifiCmdWaitRspBuf[i].cmdSn >> 8) & 0xff;
						data[2] = (wifiCmdWaitRspBuf[i].cmdSn >> 16) & 0xff;
						data[3] = (wifiCmdWaitRspBuf[i].cmdSn >> 24) & 0xff;
						data[4] = clusterId & 0xff;
						data[5] = (clusterId >> 8) & 0xff;
						data[6] = status;
						hmSetIotsEvent(HFZ_EVENT_WIFI_CMD_WAIT_RSP,shortAddr,&data[0],7);
						
						if(status != 0)
						{
							pRam->epList[0].devData.zoneStateApp.sensitivityLevel = wifiCmdWaitRspBuf[i].setData & 0xff;
						}

						wifiCmdWaitRspBuf[i].valid = 0;
						wifiCmdWaitRspBuf[i].cmdSn = 0;
						wifiCmdWaitRspBuf[i].rcvTimems = 0;
						wifiCmdWaitRspBuf[i].zbClusterId = 0;
						wifiCmdWaitRspBuf[i].zbCmd = 0;
						wifiCmdWaitRspBuf[i].zbShortAddr = 0;
						wifiCmdWaitRspBuf[i].zbEp = 0;

						userUpdateDevInfoDataToFlash(pRam);
					}
				}
			}
		}
	}
	
}

void userNewDevJoiningDetectedEvent(char *newDev,uint8_t *data,uint8_t len)
{
	uint8_t epNum = 0;
	uint8_t newDevUpOver = 0;
	uint8_t subType;
	HM_DEV_RAM_LIST *pRam;
	uint8_t i,tempEp = 0xff;
	uint8_t leaveFlag = 0;
	uint16_t devIndex,tempdata,tempdata1;
	UART_UPDATE_NEW_DEV_DATA_INFO newDevData = *(UART_UPDATE_NEW_DEV_DATA_INFO*)newDev;
	pRam = findInDevListByMac(newDevData.macAddr);
	if(pRam == NULL)
	{
		printf("the node was not in list\r\n");
		devIndex = findFreeDevIndex();
		printf("index  devIndex = findFreeDevIndex():%d,:%x\r\n",devIndex,devIndex);
		//hardy add del
		/*devIndex=devIndex & 0x7fff;
		tempdata=devIndex & 0x00ff;
		if(tempdata>0x7f){
		devIndex=devIndex & 0x7f7f;
		}//del */
		//
		if(devIndex != INVALID_DEV_INDEX)
		{
			printf("put in new dev to list,Decimal index:%d,Hex index:%x\r\n",devIndex,devIndex);
			pRam = (HM_DEV_RAM_LIST *)mem_alloc(sizeof(HM_DEV_RAM_LIST));
			pRam->index = devIndex;
			pRam->flashAddr = START_ADDR_FLASH_NODE_INFO_ADDR + (devIndex % 100) * BASIC_NODE_INFO_SIZE;
			pRam->batteryRemain = (newDevData.batteryRemain + 1) / 2;
			pRam->onLine = !(newDevData.netState & 0x01);
			pRam->shortAddr = newDevData.shortAddr;
			pRam->epNum = (newDevData.netState >> 5) & 0x07;
			printf("the net dev ep num:%d\r\n",pRam->epNum);
			
			if(pRam->epNum > SUPORT_MAX_EP_NUM)
			{
				pRam->epNum = SUPORT_MAX_EP_NUM;
			}
			memcpy(pRam->mac,newDevData.macAddr,8);
			subType = (newDevData.netState >> 1)& 0x03;
			pRam->zbSubType = subType;
			pRam->epList[0].deviceId = newDevData.deviceId;
			pRam->epList[0].ep = newDevData.epId;
			pRam->epList[0].times = gwStateForRealTime.sysRealTimeFors;
			memcpy(pRam->modeId,newDevData.modeId,ZIGBEE_MODEID_LEN);
			//hardy add
			pRam->roomId[0]=1;//
		
			getValidDevNameAndDevType(pRam,data,len);

			printf("test for battery:%d\r\n",pRam->batteryRemain);
			if((pRam->epList[0].deviceId != DEVICE_ID_IAS_ZONE) && (pRam->epList[0].deviceId != DEVICE_ID_IAS_WARNING))//非ias设备，由于IAS设备有低压报警，不需要在此判断电量剩余
			{
				if(pRam->batteryRemain < 5)//
				{
					pRam->batteryAlarm = 1;
				}else{
					pRam->batteryAlarm = 0;
				}
			}else{
				pRam->batteryAlarm = 0;
			}
			
			putNiInList(pRam);



			if(pRam->epNum == 1)
			{
				newDevUpOver = 1;
			}
		}else{
			printf("the gw not has valid index\r\n");
		}
	
	}else{
		printf("update the dev info\r\n");
		if(pRam->epNum == ((newDevData.netState  >> 5)& 0x07))//ep 个数相等
		{
			for(i = 0; i < pRam->epNum; i ++)
			{
				
				if(pRam->epList[i].ep != 0)
				{
					epNum ++;
					if(newDevData.epId == pRam->epList[i].ep)
					{
						if(pRam->epList[i].deviceId != newDevData.deviceId)
						{
							leaveFlag = 1;
							break;
						}else{
							tempEp = i;
							break;
						}
					}
				}else{
					if(tempEp == 0xff)
					{
						tempEp = i;
					}
				}
				
			}
		}
	
		if(tempEp != 0xff)
		{
			if((epNum + 1) == pRam->epNum)
			{
				newDevUpOver = 1;
				printf("\n the newDevUpOver = 1  ---------------2\n");
			}
			printf("the eplist:%d,epid:%d\r\n",tempEp,newDevData.epId);
			pRam->epList[tempEp].deviceId = newDevData.deviceId;
			pRam->epList[tempEp].ep = newDevData.epId;
			pRam->epList[tempEp].times = gwStateForRealTime.sysRealTimeFors;

			if(tempEp == 0)
			{
				pRam->batteryRemain = (newDevData.batteryRemain + 1) / 2;
				pRam->onLine = !(newDevData.netState & 0x01);
				pRam->shortAddr = newDevData.shortAddr;
				printf("test for battery:%d\r\n",pRam->batteryRemain);
				if((pRam->epList[0].deviceId != DEVICE_ID_IAS_ZONE) && (pRam->epList[0].deviceId != DEVICE_ID_IAS_WARNING))//非ias设备，由于IAS设备有低压报警，不需要在此判断电量剩余
				{
					if(pRam->batteryRemain < 5)//
					{
						pRam->batteryAlarm = 1;
					}else{
						pRam->batteryAlarm = 0;
					}
				}else{
					pRam->batteryAlarm = 0;
				}
			}

			updateNodeStateFunc(pRam,tempEp,data,len);
		}else{
			if(leaveFlag == 1)
			{
				userDeleteOneDevFromRamAndFlash(pRam);
			}
		}
	}
       if(newDevUpOver == 1)
    	{
    		printf("\n the newDevUpOver = 1  ---------------2\n");
    		gwStateForRealTime.gwZbIsJoining |= 0x02;
		//update flash 必须等待所有ep都加完后才能写flash
		userUpdateDevInfoDataToFlash(pRam);	
		userAddDevNumToNumInfo(pRam->index);
		hmSetIotsEvent(HFZ_EVENT_NEW_NODE_ADDED, pRam->shortAddr, (void *)&pRam->shortAddr,sizeof(pRam->shortAddr));// payload 保留，该值被忽略
		//userFlashInitToRam();//test test
	   }
}

void setIasAlarmDetectedEvent(HM_DEV_RAM_LIST *pni, uint16_t alarm)
{
	uint8_t alarm_enable = 0;
	uint16_t cpAlarm = alarm;
	uint8_t needSaveFlash = 0; 
	uint8_t action = 0xff;
	DEVINFOOPTION devOption;
	HM_DEV_RAM_LIST *pni_sensor = (HM_DEV_RAM_LIST *)pni;
	devOption.modeByte = 0;


	if(pni->devType == NODE_INFO_TYPE_GAS_SENSOR)
		printf("the gas test:%x\r\n",alarm);
	if(alarm & 0x10)//为心跳上报指令，无需处理
	{
		return;
	}


	pni_sensor->epList[0].times = gwStateForRealTime.sysRealTimeFors;//设备上报的时间

	if(pni_sensor->epList[0].devData.zoneStateApp.armMode == 1)
	{
		alarm_enable = 1;
	}
	printf("the gw alarm flag:%d\r\n",alarm_enable);
	if(alarm_enable)
	{
		if(cpAlarm & 0x07)
		{
			do 
			{
				if((cpAlarm & 0x20) && ((cpAlarm & 0x04) == 0))//如果为有报警恢复的设备，且不处于防拆状态
				{
					if(pni_sensor->epList[0].devData.zoneStateApp.beep_act_flag == 0)//该设备之前没有处于报警状态
					{
						pni_sensor->epList[0].devData.zoneStateApp.beep_act_flag = 1;//设备报警状态标识为置1
					}else{//防止重复报警时响应喇叭和LED灯，在收到恢复报警后再次报警时才响应喇叭和LED
						break;
					}
				}

				if((hmIotsDevInfo.beep_alarm_times != 0) && (gwStateForRealTime.gwZbIsJoining == 0))//beep time 时间有效，且网关不处于入网状态，才能启动蜂鸣器
				{
						gwStateForRealTime.gwIsAlarning = 1;//在zigbeegw_device_main函数中会置该位，在此只是及时置该位，以便下面的小夜灯功能
						if(beep_info.work_flag == 0 )
						{
								 beep_info.work_type = BEEP_ALARM;
								 beep_info.work_flag = 1;
								 tx_semaphore_put(&beep_semaphore_ptr);
						}
				}
			}while(0);
		}else{//报警恢复，或低压报警
			if(cpAlarm & 0x20)
			{
				pni_sensor->epList[0].devData.zoneStateApp.beep_act_flag = 0;
			}
		}
	}else{
		if(!(cpAlarm & 0x07))
		{
			if(cpAlarm & 0x20)
			{
				pni_sensor->epList[0].devData.zoneStateApp.beep_act_flag = 0;
			}
		}
	}

	
 	//for report the alarm to yzy 	
	if(cpAlarm & 0x08)//低电压位置1
	{
		if(pni->batteryAlarm == 0)
		{
			pni->batteryAlarm = 1;
			needSaveFlash = 1;
			writeNodeStateAlarnToCloud(pni,BATTERY_LOW_ALARM);
		}
	}else{
		if(pni->batteryAlarm == 1)
		{
			pni->batteryAlarm = 0;
			needSaveFlash = 1;
		}
	}

 	
	printf("the cp alarm was :%d\r\n",cpAlarm);
 	switch(cpAlarm & 0x07)
 	{
 		case 0://报警恢复
 			action = ALARM_RESUME;
			printf("alarm for cloud ALARM_RESUME---------01\r\n");
 			break;
		case 1:
		case 2://报警
			action = ALARM;
			printf("alarm for cloud ALARM---------01\r\n");
			break;
		case 4://防拆拆下(报警恢复)
			action = TAMPER_AND_ALARM_RESUME;
			printf("alarm for cloud TAMPER_AND_ALARM_RESUME---------01\r\n");
			break;
		case 5:
		case 6://防拆拆下(报警)
			action = TAMPER_AND_ALARM;
			printf("alarm for cloud TAMPER_AND_ALARM---------01\r\n");
			break;
		default:
			action = 0xff;
			break;
 	}
 	if(action != 0xff)
 	{
		pni_sensor->epList[0].devData.zoneStateApp.alarms = action;
		pni_sensor->epList[0].times = gwStateForRealTime.sysRealTimeFors; 
		devOption.IASState.onoff = 1;
		devOption.IASState.time = 1;
		if(alarm_enable)
		{
			printf("alarm for cloud\r\n");
			writeNodeStateAlarnToCloud(pni,action);//上报云端，推送
			userCheckDevLinkWdWasTrigger(pni->index,action);//  检测是否联动声光警号
		}else{
			printf("report for cloud\r\n");
			writeNodeStateRecordToCloud(pni,devOption);//云记录
			userDevLinkNightLight(pni);//小夜灯联动
		}
 	}

	pni->epList[0].devData.zoneStateApp.zoneStatus = cpAlarm;
	hmSetIotsEvent(HFZ_EVENT_NODE_STATE_ALARM, pni_sensor->shortAddr, (void *)&cpAlarm,sizeof(cpAlarm));//不管设备是否报警，只要状态改变就得主动上传
	//chece linkage (for working lixiong)
	userLinkageInputEventTriggerFunc(SCENE_LIST_ZB_DEV_PAYLOAD,pni,devOption);//联动触发检测

	if(needSaveFlash)
	{
		userUpdateDevInfoDataToFlash(pni_sensor);
		printf("battry state change ,need save the state to flash\r\n");
	}
}


//alarms 是设备的cluster报警，不属于设备属性内容，无需写入ep state，产生报警的时候
//直接上报给app和云即可，alarm值需重新定义
void setAlarmsAlarmDetectedEvent(HM_DEV_RAM_LIST *pni,uint16_t alarmCluster,uint8_t alarmCode)
{
	uint8_t alarm = 0;
	switch(alarmCluster)
	{
		case ZCL_DEVICE_TEMP_CLUSTER_ID:
			alarm = DEV_TEMP_UP_ALARM;
			break;
		case ZCL_TEMP_MEASUREMENT_CLUSTER_ID:
			break;
		case ZCL_ELECTRICAL_MEASUREMENT_CLUSTER_ID:
			if(alarmCode == 1)
			{
				alarm = VOLTAGE_OVER_ALARM;
			}else if(alarmCode == 2){
				alarm = CURRENT_OVER_ALARM;
			}else if(alarmCode == 4){
				alarm = POWER_W_OVER_ALARM;
			}
			break;
		default:
			printf("unknow alarms type\r\n");
			break;
	}
	if(alarm != 0)
	{
		pni->epList[0].devData.witchStateApp.alarmSta.alarmCode = alarm;
		pni->epList[0].times = gwStateForRealTime.sysRealTimeFors;
		hmSetIotsEvent(HFZ_EVENT_NODE_STATE_ALARM, pni->shortAddr, (void *)&alarm,sizeof(alarm));
		writeNodeStateAlarnToCloud(pni,alarm);
		userCheckDevLinkWdWasTrigger(pni->index,alarm);//  检测是否联动声光警号
		//chece linkage (for working lixiong)
	}
}

void setAceComDetectedEvent(HM_DEV_RAM_LIST *pni, uint8_t aceCom,uint8_t *payload,uint8_t len)
{
	uint8_t armMode;
	uint8_t action = 0xff;
	DEVINFOOPTION  devOption;
	devOption.modeByte = 0;
	printf("the ace com is:%d\r\n",aceCom);

	switch(aceCom)
	{
		case ARMMODE:
			armMode = payload[0];
			if(armMode == disarm){
				action = SENSOR_DISARM;
				hmSetAllSensorDisarm();

				if(beep_info.work_flag == 0 )
				 {
					 beep_info.work_type = BEEP_DISARM;
					 beep_info.work_flag = 1;
					 tx_semaphore_put(&beep_semaphore_ptr);
				 }
			}else if(armMode == armDay){
				action = SENSOR_HOME_ARM;
				hmSetAllSensorHomeArm();
				if((beep_info.work_flag == 0) && ((beep_info.work_type != BEEP_ALARM) && (beep_info.work_type != BEE_SOUND_LOCAL_REGULA)))
				 {
					 beep_info.work_type = BEEP_HOME_ARM;
					 beep_info.work_flag = 1;
					 tx_semaphore_put(&beep_semaphore_ptr);
				 }
			}else if(armMode == arm){
				action = SENSOR_ARM;
				hmSetAllSensorArm();
				if((beep_info.work_flag == 0) && ((beep_info.work_type != BEEP_ALARM) && (beep_info.work_type != BEE_SOUND_LOCAL_REGULA)))
				 {
					 beep_info.work_type = BEEP_ARM;
					 beep_info.work_flag = 1;
					 tx_semaphore_put(&beep_semaphore_ptr);
				 }
			}else{
				printf("the arm mode is not valid\r\n");
			}
			break;
		case BYPASS:
			break;
		case EMERGENCY:
		case FIRE:
		case PANIC:
			action = 3;//alarm
			break;
		case GETZONEMAP:
		case GETZONEINFO:
		default:
			break;
	}
	if(action != 0xff)
	{
		pni->epList[0].devData.aceStateApp.station = action;
		if(action == 3)
		{
			if((hmIotsDevInfo.beep_alarm_times != 0) && (gwStateForRealTime.gwZbIsJoining == 0))//beep time 时间有效，且网关不处于入网状态，才能启动蜂鸣器
			{
				gwStateForRealTime.gwIsAlarning = 1;//在zigbeegw_device_main函数中会置该位，在此只是及时置该位，以便下面的小夜灯功能
				if(beep_info.work_flag == 0 )
				{
					 beep_info.work_type = BEEP_ALARM;
					 beep_info.work_flag = 1;
					 tx_semaphore_put(&beep_semaphore_ptr);
				}
			}
			hmSetIotsEvent(HFZ_EVENT_NODE_STATE_ALARM, pni->shortAddr, (void *)&action,sizeof(action));
			writeNodeStateAlarnToCloud(pni,ALARM);
			userCheckDevLinkWdWasTrigger(pni->index,ALARM);//  检测是否联动声光警号
		}else{

			hmIotsDevInfo.sensor_arm_type = action;
			printf("---hmIotsDevInfo.sensor_arm_type test -------------:%d,\n",hmIotsDevInfo.sensor_arm_type );
			hmSetIotsEvent(HFZ_EVENT_NODE_STATE_CHANGE, pni->shortAddr, (void *)&action,sizeof(action));
			devOption.ACEState.onoff = 1;
			devOption.ACEState.time = 1;
			writeNodeStateRecordToCloud(pni,devOption);
		}

		////linkage(for working lixiong)
		userLinkageInputEventTriggerFunc(SCENE_LIST_ZB_DEV_PAYLOAD,pni,devOption);

	}
}
void setNodeOnoffDetectedEvent(HM_DEV_RAM_LIST *pni, uint8_t ep,uint8_t action)
{
	uint8_t i;
	DEVINFOOPTION  devOption;
	uint8_t tempState = 0;
	devOption.modeByte = 0;
	for(i = 0; i < pni->epNum; i ++)
	{
		if(pni->epList[i].ep == ep)
		{
			switch(pni->devType)
			{
				case NODE_INFO_TYPE_LIGHT_RGB:
					printf("RGB on off reprot rcv\r\n");
					if(pni->epList[i].devData.colorStateApp.onOffStatus != action)
					{
						pni->epList[i].devData.colorStateApp.onOffStatus = action;
						pni->epList[i].times = gwStateForRealTime.sysRealTimeFors;
						tempState = 1;
					}
					devOption.RGBState.onoff = 1;
					devOption.RGBState.time = 1;
					break;
				case NODE_INFO_TYPE_AI1SW:
				case NODE_INFO_TYPE_AI2SW:
				case NODE_INFO_TYPE_AI3SW:
					printf("switch on off reprot rcv\r\n");
					if(pni->epList[i].devData.witchStateApp.onOffStatus != action)
					{
						pni->epList[i].devData.witchStateApp.onOffStatus = action;
						pni->epList[i].times = gwStateForRealTime.sysRealTimeFors;
						tempState = 1;
					}
					if(ep == 1)
					{
						devOption.SWState.onoff1 = 1;
						devOption.SWState.time1 = 1;
					}else if(ep == 2){
						devOption.SWState.onoff2 = 1;
						devOption.SWState.time2 = 1;
					}else if(ep == 3){
						devOption.SWState.onoff3 = 1;
						devOption.SWState.time3 = 1;
					}
					break;
				case NODE_INFO_TYPE_CUSTOM_RGB_AREA:
					printf("switch on off reprot rcv\r\n");
					if(pni->epList[i].devData.cstRgbStateApp.onOffStatus != action)
					{
						pni->epList[i].devData.cstRgbStateApp.onOffStatus = action;
						pni->epList[0].times = gwStateForRealTime.sysRealTimeFors;
						tempState = 1;
					}
					if(ep == 1)
					{
						devOption.CUTRGBState.onoffList1 = 1;
					}else if(ep == 2){
						devOption.CUTRGBState.onoffList2 = 1;
					}else if(ep == 3){
						devOption.CUTRGBState.onoffList3 = 1;
					}else if(ep == 4){
						devOption.CUTRGBState.onoffList4 = 1;
					}
					devOption.CUTRGBState.times = 1;
					break;
				case NODE_INFO_TYPE_RELAY_CONTROL:
					printf("relay on off reprot rcv\r\n");
					if(pni->epList[i].devData.onoffOutStateApp.onOffStatus != action)
					{
						pni->epList[i].devData.onoffOutStateApp.onOffStatus = action;
						pni->epList[i].times = gwStateForRealTime.sysRealTimeFors;
						tempState = 1;
					}
					break;
				case NODE_INFO_TYPE_AI_SOCKET_USB:
					printf("usb plug on off reprot rcv\r\n");
					if(pni->epList[i].devData.onoffOutStateApp.onOffStatus != action)
					{
						pni->epList[i].devData.onoffOutStateApp.onOffStatus = action;
						pni->epList[i].times = gwStateForRealTime.sysRealTimeFors;
						tempState = 1;
					}
					if(ep == 1)
					{
						devOption.UPlugState.relayOnoff = 1;
						devOption.UPlugState.time_r = 1;
					}else if(ep == 2){
						devOption.UPlugState.usbOnoff = 1;
						devOption.UPlugState.time_u = 1;
					}
					break;
				case NODE_INFO_TYPE_AI_SOCKET_MEASURE:
					printf("smart plug on off reprot rcv\r\n");
					printf("smart plug on off reprot onOffStatus=%d,action=%d\n",pni->epList[i].devData.splugStateApp.onOffStatus,action);
					if(pni->epList[i].devData.splugStateApp.onOffStatus != action)
					{	printf("smart plug on off reprot rcv enter---\r\n");
						pni->epList[i].devData.splugStateApp.onOffStatus = action;
						pni->epList[i].times = gwStateForRealTime.sysRealTimeFors;
						tempState = 1;
					}
					devOption.SPlugState.relayOnoff = 1;
					devOption.SPlugState.time = 1;
					break;
				default:
					break;
			}
			break;
		}
	}
	if(tempState == 1)
	{
		printf("on off change to update to app\r\n");
		hmSetIotsEvent(HFZ_EVENT_NODE_STATE_CHANGE, pni->shortAddr, (void *)&action,sizeof(action));
		writeNodeStateRecordToCloud(pni,devOption);
		//app ,cloud update(for working lixiong)
		userLinkageInputEventTriggerFunc(SCENE_LIST_ZB_DEV_PAYLOAD,pni,devOption);
	}
}

void setNodeLevelDetectedEvent(HM_DEV_RAM_LIST *pni, uint8_t ep,uint8_t action)
{
	uint8_t i;
	DEVINFOOPTION  devOption;
	uint8_t tempState = 0;
	devOption.modeByte = 0;
	for(i = 0; i < pni->epNum; i ++)
	{
		if(pni->epList[i].ep == ep)
		{
			switch(pni->devType)
			{
				case NODE_INFO_TYPE_LIGHT_RGB:
					printf("RGB level reprot rcv\r\n");
					if(pni->epList[i].devData.colorStateApp.level != action)
					{
						pni->epList[i].devData.colorStateApp.level = action;
						pni->epList[i].times = gwStateForRealTime.sysRealTimeFors;
						tempState = 1;
					}
					devOption.RGBState.level = 1;
					devOption.RGBState.time = 1;
					break;
				default:
					break;
			}
			break;
		}
	}
	if(tempState == 1)
	{
		printf("level change to update to app\r\n");
		hmSetIotsEvent(HFZ_EVENT_NODE_STATE_CHANGE, pni->shortAddr, (void *)&action,sizeof(action));
		writeNodeStateRecordToCloud(pni,devOption);
		//app ,cloud update(for working lixiong)
		//userLinkageInputEventTriggerFunc(SCENE_LIST_ZB_DEV_PAYLOAD,pni,devOption);
	}
}


void setNodeColorDetectedEvent(HM_DEV_RAM_LIST *pni, uint8_t ep,char valueType,uint16_t value)
{
	uint8_t i;
	DEVINFOOPTION  devOption;
	uint16_t tempState;
	devOption.modeByte = 0;
	for(i = 0; i < pni->epNum; i ++)
	{
		if(pni->epList[i].ep == ep)
		{
			switch(pni->devType)
			{
				case NODE_INFO_TYPE_LIGHT_RGB:
					printf("RGB color reprot rcv\r\n");
					if(valueType == 'x')
					{
						tempState = pni->epList[i].devData.colorStateApp.color_x;
						pni->epList[i].devData.colorStateApp.color_x = value;
					}else if(valueType == 'y'){
						tempState = pni->epList[i].devData.colorStateApp.color_y;
						pni->epList[i].devData.colorStateApp.color_y = value;						
					}
					break;
				default:
					break;
			}
			break;
		}
	}
	if(tempState != value)
	{
		hmzColorXYToRgb(pni->epList[i].devData.colorStateApp.color_x,pni->epList[i].devData.colorStateApp.color_y,pni->epList[i].devData.colorStateApp.level,
						&pni->epList[i].devData.colorStateApp.rgb_r,&pni->epList[i].devData.colorStateApp.rgb_g,&pni->epList[i].devData.colorStateApp.rgb_b);
						printf("color change to update to app x:%d,y:%d,r:%d,g:%d,b:%d\r\n",pni->epList[i].devData.colorStateApp.color_x,pni->epList[i].devData.colorStateApp.color_y,
												pni->epList[i].devData.colorStateApp.rgb_r,pni->epList[i].devData.colorStateApp.rgb_g,pni->epList[i].devData.colorStateApp.rgb_b);
		hmSetIotsEvent(HFZ_EVENT_NODE_STATE_CHANGE, pni->shortAddr, (void *)&value,sizeof(value));
		//writeNodeStateRecordToCloud(pni,devOption);//RGB值更改无需记录到云端
	}
}

void setNodeBatteryDetectedEvent(HM_DEV_RAM_LIST *pni, uint8_t value)
{
	uint8_t tempValue,alarm = 0;
	DEVINFOOPTION  devOption;
	uint8_t needSaveFlash = 0;
	devOption.modeByte = 0;
	if(value > 200)
	{
		value == 200;
	}
	printf("receive the node battry remain:%d\r\n",value);
	tempValue = pni->batteryRemain;
	pni->batteryRemain = (value + 1)/2;
	if((pni->epList[0].deviceId != DEVICE_ID_IAS_ZONE) && (pni->epList[0].deviceId != DEVICE_ID_IAS_WARNING))//非ias设备，由于IAS设备有低压报警，不需要在此判断电量剩余
	{
		//非ias zone设备，低压只能靠网关来实现，具体低压，当电量小于5%时报低压
		if(pni->batteryAlarm == 0)
		{
			if(pni->batteryRemain < 5)//小于5%报低压
			{
				pni->batteryAlarm = 1;
				alarm = 1;
				needSaveFlash = 1;
				printf("battery alarm\r\n");
			}
		}else{
			if(pni->batteryRemain >= 10)//大于10%低压恢复，在此必须是一个区间，不然在临界点时会有问题
			{
				pni->batteryAlarm = 0;
				needSaveFlash = 1;
				printf("battery alarm resume\r\n");
			}
		}
	}else{
		//ias zone设备，有低压报警机制，但为了避免非触发时需要了解电量状态，故在此也需要做低压检测
		if(pni->batteryAlarm == 1)
		{
			if(pni->batteryRemain >= 5)//大于5%低压恢复，在此必须是一个区间，不然在临界点时会有问题
			{
				pni->batteryAlarm = 0;
				needSaveFlash = 1;
				printf("battery alarm resume for ias dev\r\n");
			}
		}
	}

	
	if(tempValue != value)
	{	//有低压，报抵压跟电量;没低压，报电量
		hmSetIotsEvent(HFZ_EVENT_NODE_STATE_CHANGE, pni->shortAddr, (void *)&value,sizeof(value));
		if((pni->epList[0].deviceId == DEVICE_ID_IAS_ZONE) || (pni->epList[0].deviceId == DEVICE_ID_IAS_ANCILLARY_CONTROL))
		{
			devOption.IASState.batteryPercent = 1;
			devOption.IASState.time = 1;
		}else if(pni->epList[0].deviceId == DEVICE_ID_IAS_WARNING){
			devOption.WDState.batteryPercent = 1;
			devOption.WDState.time = 1;
		}
		//writeNodeStateRecordToCloud(pni,devOption);//保留，暂时不记录到云端
	}
	if(alarm == 1)
	{
		writeNodeStateAlarnToCloud(pni,BATTERY_LOW_ALARM);
		userCheckDevLinkWdWasTrigger(pni->index,BATTERY_LOW_ALARM);//  检测是否联动声光警号
	}

	if(needSaveFlash)
	{
		userUpdateDevInfoDataToFlash(pni);
		printf("battry state change ,need save the state to flash\r\n");
	}
}

void setNodeTemperatureDetectedEvent(HM_DEV_RAM_LIST *pni,uint8_t ep, int16_t value)
{
	uint8_t alarm = 0;
	DEVINFOOPTION  devOption;
	uint8_t i,epIndex = 0xff;
	devOption.modeByte = 0;
	printf("receive the temperature:%d\r\n",value);
	if(value < -1000)
	{
		value = -1000;
	}else if(value > 12000){
		value  = 12000;
	}

	
	
	for(i = 0; i < pni->epNum; i ++)
	{
		if(pni->epList[i].ep == ep)
		{
			epIndex = i;
			break;
		}
	}
	if(epIndex == 0xff)
	{
		printf("the ep not find in dev info:%d \r\n",ep);
		return;
	}
	pni->epList[epIndex].devData.tempStateApp.tempMeterage = value;
	pni->epList[epIndex].times = gwStateForRealTime.sysRealTimeFors;

	if(value > pni->epList[epIndex].devData.tempStateApp.upTemp)
	{
		if(pni->epList[epIndex].devData.tempStateApp.checkEnable)
		{
			pni->epList[epIndex].devData.tempStateApp.alarms = TEMP_UP_ALARM;
			alarm = TEMP_UP_ALARM;
		}
	}else if(value < pni->epList[epIndex].devData.tempStateApp.lowTemp){
		if(pni->epList[epIndex].devData.tempStateApp.checkEnable)
		{
			pni->epList[epIndex].devData.tempStateApp.alarms = TEMP_LOW_ALARM;
			alarm = TEMP_LOW_ALARM;
		}
	}
	if(pni->devType == NODE_INFO_TYPE_TEMP_HUM_SENSOR)
	{
		devOption.THPState.temp = 1;
		devOption.THPState.humi = 1;
		devOption.THPState.time = 1;
	}
	if(alarm == 0)
	{
		pni->epList[epIndex].devData.tempStateApp.alarms = COMPARE_NORMAL;
		hmSetIotsEvent(HFZ_EVENT_NODE_STATE_CHANGE, pni->shortAddr, (void *)&value,sizeof(value));
	}else{
		hmSetIotsEvent(HFZ_EVENT_NODE_STATE_ALARM, pni->shortAddr, (void *)&value,sizeof(value));
		writeNodeStateAlarnToCloud(pni,alarm); 
		userCheckDevLinkWdWasTrigger(pni->index,alarm);//  检测是否联动声光警号
	}
	writeNodeStateRecordToCloud(pni,devOption);//不管是否报警，都需要记录值，用于曲线绘制
		
	
	
	//(for working lixiong) linkage 
	userLinkageInputEventTriggerFunc(SCENE_LIST_ZB_DEV_PAYLOAD,pni,devOption);
}

void setNodeHumilityDetectedEvent(HM_DEV_RAM_LIST *pni,uint8_t ep, uint16_t value)
{
	uint8_t alarm = 0;
	DEVINFOOPTION  devOption;
	uint8_t i,epIndex = 0xff;
	devOption.modeByte = 0;
	printf("receive the humility:%d\r\n",value);
	if(value < 200)
	{
		value = 200;
	}else if(value > 10000){
		value  = 10000;
	}

	for(i = 0; i < pni->epNum; i ++)
	{
		if(pni->epList[i].ep == ep)
		{
			epIndex = i;
			break;
		}
	}
	if(epIndex == 0xff)
	{
		printf("the ep not find in dev info:%d \r\n",ep);
		return;
	}
	pni->epList[epIndex].devData.humiStateApp.humiMeterage = value;
	pni->epList[epIndex].times = gwStateForRealTime.sysRealTimeFors;

	if(value > pni->epList[epIndex].devData.humiStateApp.upHumi)
	{
		if(pni->epList[epIndex].devData.humiStateApp.checkEnable)
		{
			pni->epList[epIndex].devData.humiStateApp.alarms = HUMI_UP_ALARM;
			alarm = HUMI_UP_ALARM;
		}
	}else if(value < pni->epList[epIndex].devData.humiStateApp.lowHumi){
		if(pni->epList[epIndex].devData.humiStateApp.checkEnable)
		{
			pni->epList[epIndex].devData.humiStateApp.alarms = HUMI_LOW_ALARM;
			alarm = HUMI_LOW_ALARM;
		}
	}
	if(pni->devType == NODE_INFO_TYPE_TEMP_HUM_SENSOR)
	{
		devOption.THPState.temp = 1;
		devOption.THPState.humi = 1;
		devOption.THPState.time = 1;
	}
	if(alarm == 0)
	{
		pni->epList[epIndex].devData.humiStateApp.alarms = COMPARE_NORMAL;
		hmSetIotsEvent(HFZ_EVENT_NODE_STATE_CHANGE, pni->shortAddr, (void *)&value,sizeof(value));
	}else{
		hmSetIotsEvent(HFZ_EVENT_NODE_STATE_ALARM, pni->shortAddr, (void *)&value,sizeof(value));
		writeNodeStateAlarnToCloud(pni,alarm);
		userCheckDevLinkWdWasTrigger(pni->index,alarm);//  检测是否联动声光警号
	}
	writeNodeStateRecordToCloud(pni,devOption);
	//(for working lixiong) linkage 
	userLinkageInputEventTriggerFunc(SCENE_LIST_ZB_DEV_PAYLOAD,pni,devOption);
}

void setNodePowerKWHDetectedEvent(HM_DEV_RAM_LIST *pni,uint8_t ep, uint64_t value)
{
	uint8_t i,epIndex = 0xff;
	DEVINFOOPTION  devOption;
	uint64_t tempValue;
	devOption.modeByte = 0;
	printf("receve power kwh:%d\r\n",value);
	for(i = 0; i < pni->epNum; i ++)
	{
		if(pni->epList[i].ep == ep)
		{
			epIndex = i;
			break;
		}
	}
	if(epIndex == 0xff)
	{
		printf("the ep not find in dev info:%d \r\n",ep);
		return;
	}
	tempValue = pni->epList[epIndex].devData.splugStateApp.CurrentSummationDelivered;
	pni->epList[epIndex].devData.splugStateApp.CurrentSummationDelivered = value;
	pni->epList[epIndex].times = gwStateForRealTime.sysRealTimeFors;
	if(value != tempValue)
	{
		if(pni->devType == NODE_INFO_TYPE_AI_SOCKET_MEASURE)
		{
			devOption.SPlugState.power_wh = 1;
			devOption.SPlugState.time = 1;
		}
		hmSetIotsEvent(HFZ_EVENT_NODE_STATE_CHANGE, pni->shortAddr, (void *)&value,sizeof(value));
		writeNodeStateRecordToCloud(pni,devOption);
	}
	userLinkageInputEventTriggerFunc(SCENE_LIST_ZB_DEV_PAYLOAD,pni,devOption);
}

void setNodePowerKWDetectedEvent(HM_DEV_RAM_LIST *pni,uint8_t ep, uint32_t value)
{
	uint8_t i,epIndex = 0xff;
	uint32_t tempValue;
	DEVINFOOPTION  devOption;
	devOption.modeByte = 0;
	printf("receve power kw:%d\r\n",value);
	for(i = 0; i < pni->epNum; i ++)
	{
		if(pni->epList[i].ep == ep)
		{
			epIndex = i;
			break;
		}
	}
	if(epIndex == 0xff)
	{
		printf("the ep not find in dev info:%d \r\n",ep);
		return;
	}
	tempValue = pni->epList[epIndex].devData.splugStateApp.InstantaneousDemand;
	pni->epList[epIndex].devData.splugStateApp.InstantaneousDemand = value;
	if(value != tempValue)
	{
		hmSetIotsEvent(HFZ_EVENT_NODE_UPDATE_SPECIAL, pni->shortAddr, (void *)&value,sizeof(value));

		devOption.SPlugState.power_w = 1;
		userLinkageInputEventTriggerFunc(SCENE_LIST_ZB_DEV_PAYLOAD,pni,devOption);
	}
	
}


void setNodeVoltageDetectedEvent(HM_DEV_RAM_LIST *pni,uint8_t ep, uint16_t value)
{
	uint8_t i,epIndex = 0xff;
	uint32_t tempValue;
	printf("receve voltage:%d\r\n",value);
	for(i = 0; i < pni->epNum; i ++)
	{
		if(pni->epList[i].ep == ep)
		{
			epIndex = i;
			break;
		}
	}
	if(epIndex == 0xff)
	{
		printf("the ep not find in dev info:%d \r\n",ep);
		return;
	}
	tempValue = pni->epList[epIndex].devData.splugStateApp.rmsVoltage;
	pni->epList[epIndex].devData.splugStateApp.rmsVoltage = value;

	if(tempValue != value)
	{
		hmSetIotsEvent(HFZ_EVENT_NODE_STATE_CHANGE, pni->shortAddr, (void *)&value,sizeof(value));
	}

}


/**********************************************************************
客户定制的四区灯控系统，不需要每一路记录一个时间，
由于app上只能显示一个时间，故将eplist[0]的时间设定为设备
的时间，即任何时候对改设备的时间记录、读取都只需要
操作eplist[0]的时间
**********************************************************************/
void setNodeBrightnessDetectedEvent(HM_DEV_RAM_LIST *pni,uint8_t ep, uint8_t value)
{
	uint8_t i,epIndex = 0xff;
	uint32_t tempValue;
	DEVINFOOPTION  devOption;
	devOption.modeByte = 0;
	printf("receve brightness:%d\r\n",value);
	for(i = 0; i < pni->epNum; i ++)
	{
		if(pni->epList[i].ep == ep)
		{
			epIndex = i;
			break;
		}
	}
	if(epIndex == 0xff)
	{
		printf("the ep not find in dev info:%d \r\n",ep);
		return;
	}
	tempValue = pni->epList[epIndex].devData.cstRgbStateApp.brightness;
	pni->epList[epIndex].devData.cstRgbStateApp.brightness = value;

	if(tempValue != value)
	{
		pni->epList[0].times = gwStateForRealTime.sysRealTimeFors;
		if(pni->devType == NODE_INFO_TYPE_CUSTOM_RGB_AREA)
		{
			if(epIndex == 1)
			{
				devOption.CUTRGBState.brightnessList1 = 1;
			}else if(epIndex == 2){
				devOption.CUTRGBState.brightnessList2 = 1;
			}else if(epIndex == 3){
				devOption.CUTRGBState.brightnessList3 = 1;
			}else if(epIndex == 4){
				devOption.CUTRGBState.brightnessList4 = 1;
			}
			devOption.SPlugState.time = 1;
		}
		
		hmSetIotsEvent(HFZ_EVENT_NODE_STATE_CHANGE, pni->shortAddr, (void *)&value,sizeof(value));
		writeNodeStateRecordToCloud(pni,devOption);
	}
}


/**********************************************************************
客户定制的四区灯控系统，不需要每一路记录一个时间，
由于app上只能显示一个时间，故将eplist[0]的时间设定为设备
的时间，即任何时候对改设备的时间记录、读取都只需要
操作eplist[0]的时间
**********************************************************************/
void setNodeColorTempDetectedEvent(HM_DEV_RAM_LIST *pni,uint8_t ep, uint16_t value)
{
	uint8_t i,epIndex = 0xff;
	uint32_t tempValue;
	DEVINFOOPTION  devOption;
	devOption.modeByte = 0;
	printf("receve color temperature:%d\r\n",value);

	for(i = 0; i < pni->epNum; i ++)
	{
		if(pni->epList[i].ep == ep)
		{
			epIndex = i;
			break;
		}
	}
	if(epIndex == 0xff)
	{
		printf("the ep not find in dev info:%d \r\n",ep);
		return;
	}
	tempValue = pni->epList[epIndex].devData.cstRgbStateApp.colorTemrature;
	pni->epList[epIndex].devData.cstRgbStateApp.colorTemrature = value;

	if(tempValue != value)
	{
		pni->epList[0].times = gwStateForRealTime.sysRealTimeFors;
		if(pni->devType == NODE_INFO_TYPE_CUSTOM_RGB_AREA)
		{
			if(epIndex == 1)
			{
				devOption.CUTRGBState.colorTempList1 = 1;
			}else if(epIndex == 2){
				devOption.CUTRGBState.colorTempList2 = 1;
			}else if(epIndex == 3){
				devOption.CUTRGBState.colorTempList3 = 1;
			}else if(epIndex == 4){
				devOption.CUTRGBState.colorTempList4 = 1;
			}
			devOption.SPlugState.time = 1;
		}
		
		hmSetIotsEvent(HFZ_EVENT_NODE_STATE_CHANGE, pni->shortAddr, (void *)&value,sizeof(value));
		writeNodeStateRecordToCloud(pni,devOption);
	}
}

void setNodeOnlineUpdateDetectedEvent(HM_DEV_RAM_LIST *pni, uint8_t state)
{
	printf("update %02x dev onlin to:%d\r\n",pni->shortAddr,state);

	if(state == 0)
	{
		if(pni->onLine != state)
		{
			//writeNodeStateAlarnToCloud(pni,SUB_DEV_OFFLINE);
		}
	}
	pni->onLine = state;
	hmSetIotsEvent(HFZ_EVENT_NODE_STATE_CHANGE, pni->shortAddr, (void *)&state,sizeof(state));
	userUpdateDevInfoDataToFlash(pni);
}





void setNodeRemoveDetectedEvent(uint16_t index)
{
	printf("node remove\r\n");
	hmSetIotsEvent(HFZ_EVENT_NODE_REMOVED, 0, (void *)&index,sizeof(index));
}

void setNodeSensitivityLevelEvent(HM_DEV_RAM_LIST *pni, uint8_t state)
{
	printf("the node sensitivity level:%d\r\n",state);
	pni->epList[0].devData.zoneStateApp.sensitivityLevel = state;
}

void updateNodeStateFunc(HM_DEV_RAM_LIST *pni, uint8_t eplistId,uint8_t *payload,uint8_t len)
{
	uint8_t i;
	uint8_t devType = NODE_INFO_TYPE_UNKNOWN;
	uint8_t temp_arm = 1;
	char mac_addr[10];

	switch(pni->devType)
	{
		case NODE_INFO_TYPE_LIGHT_RGB:
			printf("RGB state update  rcv,payload len:%d\r\n",len);
			if(len == 9)
			{
				pni->epList[eplistId].devData.colorStateApp.onOffStatus = payload[0];
				pni->epList[eplistId].devData.colorStateApp.level = payload[1];
				//pni->epList[eplistId].devData.colorStateApp.hue = payload[2];
				pni->epList[eplistId].devData.colorStateApp.color_x = payload[3] + ((uint16_t)payload[4] << 8);
				pni->epList[eplistId].devData.colorStateApp.color_y = payload[5] + ((uint16_t)payload[6] << 8);
				//pni->epList[eplistId].devData.colorStateApp.color_temp = payload[7] + ((uint16_t)payload[8] << 8);
				hmzColorXYToRgb(pni->epList[eplistId].devData.colorStateApp.color_x,pni->epList[eplistId].devData.colorStateApp.color_y,pni->epList[eplistId].devData.colorStateApp.level,
								&pni->epList[eplistId].devData.colorStateApp.rgb_r,&pni->epList[eplistId].devData.colorStateApp.rgb_g,&pni->epList[eplistId].devData.colorStateApp.rgb_b);
			}else{
				printf("the update sta len was error\r\n");
			}
			break;
		case NODE_INFO_TYPE_AI1SW:
		case NODE_INFO_TYPE_AI2SW:
		case NODE_INFO_TYPE_AI3SW:
			printf("switch state update  rcv,payload len:%d\r\n",len);
			if(len == 1)
			{
				pni->epList[eplistId].devData.witchStateApp.onOffStatus = payload[0];
			}else{
				printf("the update sta len was error\r\n");
			}
			break;
		case NODE_INFO_TYPE_RELAY_CONTROL:
			printf("relay state update  rcv,payload len:%d\r\n",len);
			if(len == 1)
			{
				pni->epList[eplistId].devData.onoffOutStateApp.onOffStatus = payload[0];
			}else{
				printf("the update sta len was error\r\n");
			}
			break;
		case NODE_INFO_TYPE_AI_SOCKET_USB:
			printf("socket state update  rcv,payload len:%d\r\n",len);
			if(len == 1)
			{
				pni->epList[eplistId].devData.onoffOutStateApp.onOffStatus = payload[0];
			}else{
				printf("the update sta len was error\r\n");
			}
			break;
		case NODE_INFO_TYPE_AI_SOCKET_MEASURE:
			printf("smart plug state update  rcv,payload len:%d\r\n",len);
			if(len == 15)
			{
				pni->epList[eplistId].devData.splugStateApp.onOffStatus = payload[0];
				pni->epList[eplistId].devData.splugStateApp.rmsVoltage = payload[1] + ((uint16_t)payload[2] << 8);
				pni->epList[eplistId].devData.splugStateApp.InstantaneousDemand = payload[3] + ((uint32_t)payload[4] << 8) +
																		   ((uint32_t)payload[5] << 16) + ((uint32_t)payload[6] << 24);
				pni->epList[eplistId].devData.splugStateApp.CurrentSummationDelivered =  ((uint64_t)payload[7] << 0) + ((uint64_t)payload[8] << 8) +
																				((uint64_t)payload[9] << 16) + ((uint64_t)payload[10] << 24) +
																			   ((uint64_t)payload[11] << 32) + ((uint64_t)payload[12] << 40) +
																			    ((uint64_t)payload[13] << 48) + ((uint64_t)payload[14] << 56) ;	
			}else{
				printf("the update sta len was error\r\n");
			}
			break;
		case NODE_INFO_TYPE_TEMP_HUM_SENSOR:
			printf("thp state update  rcv,payload len:%d\r\n",len);
			if(len == 2)
			{
				if(pni->epNum >1)
				{
					if(pni->epList[eplistId].ep == 1)
					{
						pni->epList[eplistId].devData.tempStateApp.tempMeterage = payload[0] + ((uint16_t)payload[1] << 8);
					}else{
						pni->epList[eplistId].devData.humiStateApp.humiMeterage = payload[0] + ((uint16_t)payload[1] << 8);
					}
				}else{
					pni->epList[eplistId].devData.tempStateApp.tempMeterage = payload[0] + ((uint16_t)payload[1] << 8);
				}
			}else{
				printf("the update sta len was error\r\n");
			}
			break;
		case NODE_INFO_TYPE_REMOTE_CONTROL:
			printf("ace state update  rcv,payload len:%d\r\n",len);
			if(len == 2)
			{
				pni->epList[eplistId].devData.aceStateApp.comId = payload[0];
				pni->epList[eplistId].devData.aceStateApp.modeId = payload[1];
			}else{
				printf("the update sta len was error\r\n");
			}
			break;
		case NODE_INFO_TYPE_CUSTOM_RGB_AREA:
			printf("for custom rgb state update\r\n");
			if(len == 4)
			{
				pni->epList[eplistId].devData.cstRgbStateApp.onOffStatus = payload[0];
				pni->epList[eplistId].devData.cstRgbStateApp.brightness = payload[1];
				pni->epList[eplistId].devData.cstRgbStateApp.colorTemrature = payload[2] + ((uint16_t)payload[3] << 8);
			}else{
				printf("the update sta len was error\r\n");
			}
			break;
		default:
			if(pni->epList[eplistId].deviceId == DEVICE_ID_IAS_ZONE)
			{
				printf("ias state update  rcv,payload len:%d\r\n",len);
				if(len == 5)
				{
					pni->epList[eplistId].devData.zoneStateApp.zoneId = payload[0];
					pni->epList[eplistId].devData.zoneStateApp.zoneType = payload[1] + ((uint16_t)payload[2] << 8);
					pni->epList[eplistId].devData.zoneStateApp.zoneStatus = payload[3] + ((uint16_t)payload[4] << 8);
					if((pni->batteryRemain < 30) || (pni->epList[eplistId].devData.zoneStateApp.zoneStatus & 0x08))
					{
						pni->batteryAlarm = 1;
					}
					if(pni->devType == NODE_INFO_TYPE_UNKNOWN)
					{
						memset(mac_addr, 0, 10);
						for(i=0; i<3; i++)
						{
							if(pni->mac[i] < 0x10)
								sprintf(mac_addr, "%s0%X", mac_addr, pni->mac[i]);
							else
								sprintf(mac_addr, "%s%X", mac_addr, pni->mac[i]);
						}
						switch(pni->epList[eplistId].devData.zoneStateApp.zoneType)
						{
							case EMBER_ZCL_IAS_ZONE_TYPE_MOTION_SENSOR:
								if((hmIotsDevInfo.sensor_arm_type == SENSOR_DISARM) || (hmIotsDevInfo.sensor_arm_type == SENSOR_HOME_ARM))
								{
									temp_arm = 0;//撤防
								}
								devType = NODE_INFO_TYPE_PIR_SENSOR;
								sprintf((char *)pni->name, "Pir_%s", mac_addr);
								break;
							case EMBER_ZCL_IAS_ZONE_TYPE_CONTACT_SWITCH:
								if(hmIotsDevInfo.sensor_arm_type == SENSOR_DISARM)
								{
									temp_arm = 0;//撤防
								}
								devType = NODE_INFO_TYPE_MAGNET_DOOR;
								sprintf((char *)pni->name, "WDoor_%s", mac_addr);
								break;
							case EMBER_ZCL_IAS_ZONE_TYPE_FIRE_SENSOR:
								devType = NODE_INFO_TYPE_SMOKE_SENSOR;
								sprintf((char *)pni->name, "Smoke_%s", mac_addr);
								break;
							case EMBER_ZCL_IAS_ZONE_TYPE_WATER_SENSOR:
								devType = NODE_INFO_TYPE_WATER_SENSOR;
								sprintf((char *)pni->name, "Water_%s", mac_addr);
								break;
							case EMBER_ZCL_IAS_ZONE_TYPE_GAS_SENSOR:
								if(pni->zbSubType == ZIGBEE_ZED_RECEIVE_OFF_IN_IDLE)
								{
									devType = NODE_INFO_TYPE_CO_SENSOR;
									sprintf((char *)pni->name, "CO_%s", mac_addr);
								}else{
									devType = NODE_INFO_TYPE_GAS_SENSOR;
									sprintf((char *)pni->name, "Gas_%s", mac_addr);
								}
								break;
							case EMBER_ZCL_IAS_ZONE_TYPE_PERSONAL_EMERGENCY_DEVICE:
								break;
							case EMBER_ZCL_IAS_ZONE_TYPE_VIBRATION_MOVEMENT_SENSOR:
								if(hmIotsDevInfo.sensor_arm_type == SENSOR_DISARM)
								{
									temp_arm = 0;//撤防
								}
								devType = NODE_INFO_TYPE_VIBRATION;
								sprintf((char *)pni->name, "%s%s",NODE_INFO_TYPE_VIBRATION_STRING, mac_addr);
								break;
							case EMBER_ZCL_IAS_ZONE_TYPE_REMOTE_CONTROL:
								break;
							case EMBER_ZCL_IAS_ZONE_TYPE_KEY_FOB:
								devType = NODE_INFO_TYPE_SOS;
								sprintf((char *)pni->name, "Eb_%s", mac_addr);
								break;
							case EMBER_ZCL_IAS_ZONE_TYPE_KEYPAD:
								break;
							case EMBER_ZCL_IAS_ZONE_TYPE_STANDARD_WARNING_DEVICE:
								break;
							case EMBER_ZCL_IAS_ZONE_TYPE_GLASS_BREAK_SENSOR:
								break;
							case EMBER_ZCL_IAS_ZONE_TYPE_CARBON_MONOXIDE_SENSOR:
								break;
							case EMBER_ZCL_IAS_ZONE_TYPE_SECURITY_REPEATER:
								break;
							default:
								break;
						}
						pni->devType = devType;
						pni->epList[eplistId].devData.zoneStateApp.armMode = temp_arm;
						printf("the new name:%s\r\n",pni->name);
						userUpdateDevInfoDataToFlash(pni);//保存到flash中
					}
				}else{
					printf("the update sta len was error\r\n");
				}
			}
			break;
	}

}

